/*
The MIT License (MIT)

Copyright (c) 2018 TOML authors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
// Tests are mostly taken from https://github.com/BurntSushi/toml-test

// This file is generated by ./tests/generate-grain-tests.js

module TomlTest

include "../toml"
include "result"
include "list"
from Toml use { fromString, type Toml }
// Sort
let rec innerSortToml = tomlTree => {
  match (tomlTree) {
    TomlTable(tableItems) => {
      let tableItems = List.map(((key, value)) =>
        (key, innerSortToml(value)), tableItems)
      let tableItems = List.sort(((keyA, _), (keyB, _)) => {
        compare(keyA, keyB)
      }, tableItems)
      TomlTable(tableItems)
    },
    TomlArray(arrItems) => {
      let arrItems = List.map(innerSortToml, arrItems)
      TomlArray(arrItems)
    },
    _ => tomlTree,
  }
}
let sortToml = tomlTree => {
  match (tomlTree) {
    Ok(tomlTree) => Ok(innerSortToml(tomlTree)),
    Err(err) => Err(err),
  }
}

// Invalid Tests

// invalid

// table
assert Result.isErr(fromString("[[a.b]]\n\n[a]\nb.y = 2\n"))
// assert Result.isErr(
//   fromString(
//     "# First a.b.c defines a table: a.b.c = {z=9}\n#\n# Then we define a.b.c.t = \"str\" to add a str to the above table, making it:\n#\n#   a.b.c = {z=9, t=\"...\"}\n#\n# While this makes sense, logically, it was decided this is not valid TOML as\n# it's too confusing/convoluted.\n# \n# See: https://github.com/toml-lang/toml/issues/846\n#      https://github.com/toml-lang/toml/pull/859\n\n[a.b.c]\n  z = 9\n\n[a]\n  b.c.t = \"Using dotted keys to add to [a.b.c] after explicitly defining it above is not allowed\"\n"
//   )
// )
// assert Result.isErr(
//   fromString(
//     "# This is the same issue as in injection-1.toml, except that nests one level\n# deeper. See that file for a more complete description.\n\n[a.b.c.d]\n  z = 9\n\n[a]\n  b.c.d.k.t = \"Using dotted keys to add to [a.b.c.d] after explicitly defining it above is not allowed\"\n"
//   )
// )
assert Result.isErr(fromString("[[]]\nname = \"Born to Run\"\n"))
assert Result.isErr(
  fromString(
    "# This test is a bit tricky. It should fail because the first use of\n# `[[albums.songs]]` without first declaring `albums` implies that `albums`\n# must be a table. The alternative would be quite weird. Namely, it wouldn't\n# comply with the TOML spec: \"Each double-bracketed sub-table will belong to \n# the most *recently* defined table element *above* it.\"\n#\n# This is in contrast to the *valid* test, table-array-implicit where\n# `[[albums.songs]]` works by itself, so long as `[[albums]]` isn't declared\n# later. (Although, `[albums]` could be.)\n[[albums.songs]]\nname = \"Glory Days\"\n\n[[albums]]\nname = \"Born in the USA\"\n"
  )
)
assert Result.isErr(fromString("[[albums]\nname = \"Born to Run\"\n"))
assert Result.isErr(
  fromString("[fruit]\napple.color = \"red\"\n\n[[fruit.apple]]\n")
)
// assert Result.isErr(
//   fromString("[fruit]\napple.color = \"red\"\n\n[fruit.apple] # INVALID\n")
// )
// assert Result.isErr(
//   fromString(
//     "[fruit]\napple.taste.sweet = true\n\n[fruit.apple.taste] # INVALID\n"
//   )
// )
assert Result.isErr(
  fromString("[fruit]\ntype = \"apple\"\n\n[fruit.type]\napple = \"yes\"\n")
)
assert Result.isErr(fromString("[tbl]\n[[tbl]]\n"))
assert Result.isErr(fromString("[[tbl]]\n[tbl]\n"))
assert Result.isErr(fromString("[a]\nb = 1\n\n[a]\nc = 2\n"))
assert Result.isErr(fromString("[naughty..naughty]\n"))
assert Result.isErr(fromString("[]\n"))
assert Result.isErr(fromString("[name=bad]\n"))
assert Result.isErr(fromString("[ [table]]\n"))
assert Result.isErr(fromString("[a]b]\nzyx = 42\n"))
assert Result.isErr(fromString("[a[b]\nzyx = 42\n"))
assert Result.isErr(fromString("[\"where will it end]\nname = value\n"))
assert Result.isErr(
  fromString(
    "# Define b as int, and try to use it as a table: error\n[a]\nb = 1\n\n[a.b]\nc = 2\n"
  )
)
assert Result.isErr(fromString("[[table] ]\n"))
assert Result.isErr(fromString("[error] this shouldn't be here\n"))
assert Result.isErr(fromString("[invalid key]\n"))
assert Result.isErr(fromString("[key#group]\nanswer = 42\n"))

// string
assert Result.isErr(fromString("naughty = \"\\xAg\"\n"))
assert Result.isErr(
  fromString(
    "invalid-codepoint = \"This string contains a non scalar unicode codepoint \\uD801\"\n"
  )
)
assert Result.isErr(fromString("no_concat = \"first\" \"second\"\n"))
assert Result.isErr(
  fromString(
    "invalid-escape = \"This string has a bad \\a escape character.\"\n"
  )
)
assert Result.isErr(
  fromString(
    "invalid-escape = \"This string has a bad \\  escape character.\"\n\n"
  )
)
assert Result.isErr(fromString("bad-hex-esc-1 = \"\\x0g\"\n"))
assert Result.isErr(fromString("bad-hex-esc-2 = \"\\xG0\"\n"))
assert Result.isErr(fromString("bad-hex-esc-3 = \"\\x\"\n"))
assert Result.isErr(fromString("bad-hex-esc-4 = \"\\x 50\"\n"))
assert Result.isErr(fromString("bad-hex-esc-5 = \"\\x 50\"\n"))
assert Result.isErr(fromString("multi = \"first line\nsecond line\"\n"))
assert Result.isErr(
  fromString(
    "invalid-escape = \"This string has a bad \\/ escape character.\"\n"
  )
)
assert Result.isErr(fromString("str = \"val\\ue\"\n"))
assert Result.isErr(fromString("str = \"val\\Ux\"\n"))
assert Result.isErr(fromString("str = \"val\\U0000000\"\n\n"))
assert Result.isErr(fromString("str = \"val\\U0000\"\n"))
assert Result.isErr(fromString("str = \"val\\Ugggggggg\"\n"))
assert Result.isErr(fromString("a = \"\"\"\\UFFFFFFFF\"\"\"\n"))
assert Result.isErr(fromString("a = \"\"\"\\U00D80000\"\"\"\n"))
assert Result.isErr(
  fromString("str5 = \"\"\"Here are three quotation marks: \"\"\".\"\"\"\n")
)
assert Result.isErr(fromString("a = \"\"\"\\@\"\"\"\n"))
assert Result.isErr(fromString("a = \"\\UFFFFFFFF\"\n"))
assert Result.isErr(fromString("a = \"\\U00D80000\"\n"))
assert Result.isErr(fromString("a = \"\\@\"\n"))
assert Result.isErr(fromString("a = '''6 apostrophes: ''''''\n\n"))
assert Result.isErr(fromString("a = '''15 apostrophes: ''''''''''''''''''\n"))
assert Result.isErr(fromString("name = value\n"))
assert Result.isErr(fromString("k = \"\"\"t\\a\"\"\"\n\n"))
assert Result.isErr(
  fromString("# \\<Space> is not a valid escape.\nk = \"\"\"t\\ t\"\"\"\n")
)
assert Result.isErr(
  fromString("# \\<Space> is not a valid escape.\nk = \"\"\"t\\ \"\"\"\n\n")
)
assert Result.isErr(fromString("a = \"\"\"\n  foo \\ \\n\n  bar\"\"\"\n"))
assert Result.isErr(fromString("x=\"\"\"\n"))
assert Result.isErr(fromString("invalid = \"\"\"\n    this will fail\n"))
assert Result.isErr(fromString("a = \"\"\"6 quotes: \"\"\"\"\"\"\n"))
assert Result.isErr(fromString("no-ending-quote = \"One time, at band camp\n"))
assert Result.isErr(
  fromString("string = \"Is there life after strings?\" No.\n")
)
assert Result.isErr(fromString("bad-ending-quote = \"double and single'\n"))

// spec
// assert Result.isErr(
//   fromString(
//     "[product]\ntype = { name = \"Nail\" }\ntype.edible = false  # INVALID\n"
//   )
// )
// assert Result.isErr(
//   fromString(
//     "[product]\ntype.name = \"Nail\"\ntype = { edible = false }  # INVALID\n"
//   )
// )
assert Result.isErr(fromString("key = # INVALID\n"))
assert Result.isErr(
  fromString(
    "= \"no key name\"  # INVALID\n\"\" = \"blank\"     # VALID but discouraged\n'' = 'blank'     # VALID but discouraged\n"
  )
)
assert Result.isErr(
  fromString(
    "str4 = \"\"\"Here are two quotation marks: \"\". Simple enough.\"\"\"\nstr5 = \"\"\"Here are three quotation marks: \"\"\".\"\"\"  # INVALID\nstr5 = \"\"\"Here are three quotation marks: \"\"\\\".\"\"\"\nstr6 = \"\"\"Here are fifteen quotation marks: \"\"\\\"\"\"\\\"\"\"\\\"\"\"\\\"\"\"\\\".\"\"\"\n\n# \"This,\" she said, \"is just a pointless statement.\"\nstr7 = \"\"\"\"This,\" she said, \"is just a pointless statement.\"\"\"\"\n"
  )
)
assert Result.isErr(
  fromString(
    "quot15 = '''Here are fifteen quotation marks: \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"'''\n\napos15 = '''Here are fifteen apostrophes: ''''''''''''''''''  # INVALID\napos15 = \"Here are fifteen apostrophes: '''''''''''''''\"\n\n# 'That,' she said, 'is still pointless.'\nstr = ''''That,' she said, 'is still pointless.''''\n"
  )
)
// assert Result.isErr(
//   fromString(
//     "[fruit]\napple.color = \"red\"\napple.taste.sweet = true\n\n[fruit.apple]  # INVALID\n# [fruit.apple.taste]  # INVALID\n\n[fruit.apple.texture]  # you can add sub-tables\nsmooth = true\n"
//   )
// )
// assert Result.isErr(
//   fromString(
//     "[fruit]\napple.color = \"red\"\napple.taste.sweet = true\n\n# [fruit.apple]  # INVALID\n[fruit.apple.taste]  # INVALID\n\n[fruit.apple.texture]  # you can add sub-tables\nsmooth = true\n"
//   )
// )

// key
assert Result.isErr(fromString("[[agencies]] owner = \"S Cjelli\"\n"))
assert Result.isErr(fromString("[error] this = \"should not be here\"\n"))
assert Result.isErr(
  fromString("first = \"Tom\" last = \"Preston-Werner\" # INVALID\n")
)
assert Result.isErr(fromString("bare!key = 123\n"))
assert Result.isErr(
  fromString(
    "# Defined a.b as int\na.b = 1\n# Tries to access it as table: error\na.b.c = 2\n"
  )
)
assert Result.isErr(fromString("dupe = false\ndupe = true\n"))
assert Result.isErr(
  fromString("# DO NOT DO THIS\nname = \"Tom\"\nname = \"Pradyun\"\n")
)
assert Result.isErr(fromString(" = 1\n"))
assert Result.isErr(
  fromString("\\u00c0 = \"latin capital letter A with grave\"\n")
)
assert Result.isErr(fromString("a# = 1\n"))
assert Result.isErr(fromString("\"\"\"long\nkey\"\"\" = 1\n"))
assert Result.isErr(fromString("barekey\n   = 123\n"))
assert Result.isErr(fromString("a = 1 b = 2\n"))
assert Result.isErr(fromString("[abc = 1\n"))
assert Result.isErr(fromString("partial\"quoted\" = 5\n"))
assert Result.isErr(fromString("\"key = x\n"))
assert Result.isErr(fromString("\"key\n"))
assert Result.isErr(fromString("[\n"))
assert Result.isErr(fromString("a b = 1\n"))
assert Result.isErr(fromString("[a]\n[xyz = 5\n[b]\n"))
assert Result.isErr(fromString(".key = 1\n"))
assert Result.isErr(fromString("key= = 1\n"))
assert Result.isErr(fromString("a==1\n"))
assert Result.isErr(fromString("a=b=1\n"))
assert Result.isErr(fromString("key\n"))
assert Result.isErr(fromString("key = \n"))
assert Result.isErr(fromString("\"key\"\n"))
assert Result.isErr(fromString("\"key\" = \n"))

// integer
assert Result.isErr(fromString("capital-bin = 0B0\n"))
assert Result.isErr(fromString("capital-hex = 0X1\n"))
assert Result.isErr(fromString("capital-oct = 0O0\n"))
assert Result.isErr(fromString("double-sign-nex = --99\n"))
assert Result.isErr(fromString("double-sign-plus = ++99\n"))
assert Result.isErr(fromString("double-us = 1__23\n"))
assert Result.isErr(fromString("incomplete-bin = 0b\n"))
assert Result.isErr(fromString("incomplete-hex = 0x\n"))
assert Result.isErr(fromString("incomplete-oct = 0o\n"))
assert Result.isErr(fromString("invalid-bin = 0b0012\n"))
assert Result.isErr(fromString("invalid-hex = 0xaafz\n"))
assert Result.isErr(fromString("invalid-oct = 0o778\n"))
assert Result.isErr(fromString("leading-us-bin = _0o1\n"))
assert Result.isErr(fromString("leading-us-hex = _0o1\n"))
assert Result.isErr(fromString("leading-us-oct = _0o1\n"))
assert Result.isErr(fromString("leading-us = _123\n"))
assert Result.isErr(fromString("leading-zero-1 = 01\n"))
assert Result.isErr(fromString("leading-zero-2 = 00\n"))
assert Result.isErr(fromString("leading-zero-3 = 0_0\n"))
assert Result.isErr(fromString("leading-zero-sign-1 = -01\n"))
assert Result.isErr(fromString("leading-zero-sign-2 = +01\n"))
assert Result.isErr(fromString("leading-zero-sign-3 = +0_1\n"))
assert Result.isErr(fromString("negative-bin = -0b11010110\n"))
assert Result.isErr(fromString("negative-hex = -0xff\n"))
assert Result.isErr(fromString("negative-oct = -0o99\n"))
assert Result.isErr(fromString("positive-bin = +0b11010110\n"))
assert Result.isErr(fromString("positive-hex = +0xff\n"))
assert Result.isErr(fromString("positive-oct = +0o99\n"))
assert Result.isErr(fromString("answer = 42 the ultimate answer?\n"))
assert Result.isErr(fromString("trailing-us-bin = 0b1_\n"))
assert Result.isErr(fromString("trailing-us-hex = 0x1_\n"))
assert Result.isErr(fromString("trailing-us-oct = 0o1_\n"))
assert Result.isErr(fromString("trailing-us = 123_\n"))
assert Result.isErr(fromString("us-after-bin = 0b_1\n"))
assert Result.isErr(fromString("us-after-hex = 0x_1\n"))
assert Result.isErr(fromString("us-after-oct = 0o_1\n"))

// inline-table
// assert Result.isErr(
//   fromString(
//     "a={}\n# Inline tables are immutable and can't be extended\n[a.b]\n"
//   )
// )
assert Result.isErr(fromString("tbl = { a = 1, [b] }\n"))
assert Result.isErr(fromString("tbl = { a.b = \"a_b\", a.b.c = \"a_b_c\" }\n"))
assert Result.isErr(fromString("t = {x=3,,y=4}\n"))
assert Result.isErr(
  fromString(
    "# Duplicate keys within an inline table are invalid\na={b=1, b=2}\n"
  )
)
assert Result.isErr(fromString("t = {,}\n"))
assert Result.isErr(
  fromString(
    "tbl = { fruit = { apple.color = \"red\" }, fruit.apple.texture = { smooth = true } }\n\n"
  )
)
assert Result.isErr(fromString("t = {x = 3 y = 4}\n"))
// assert Result.isErr(
//   fromString(
//     "a.b=0\n# Since table \"a\" is already defined, it can't be replaced by an inline table.\na={}\n"
//   )
// )

// float
assert Result.isErr(fromString("double-point-1 = 0..1\n"))
assert Result.isErr(fromString("double-point-2 = 0.1.2\n"))
assert Result.isErr(fromString("exp-double-e-1 = 1ee2\n"))
assert Result.isErr(fromString("exp-double-e-2 = 1e2e3\n"))
assert Result.isErr(fromString("exp-double-us = 1e__23\n"))
assert Result.isErr(fromString("exp-leading-us = 1e_23\n"))
assert Result.isErr(fromString("exp-point-1 = 1e2.3\n"))
assert Result.isErr(fromString("exp-point-2 = 1.e2\n"))
assert Result.isErr(fromString("exp-trailing-us = 1e_23_\n"))
assert Result.isErr(fromString("v = Inf\n"))
assert Result.isErr(fromString("inf-incomplete-1 = in\n"))
assert Result.isErr(fromString("inf-incomplete-2 = +in\n"))
assert Result.isErr(fromString("inf-incomplete-3 = -in\n"))
assert Result.isErr(fromString("inf_underscore = in_f\n"))
assert Result.isErr(fromString("leading-point-neg = -.12345\n"))
assert Result.isErr(fromString("leading-point-plus = +.12345\n"))
assert Result.isErr(fromString("leading-point = .12345\n"))
assert Result.isErr(fromString("leading-us = _1.2\n"))
assert Result.isErr(fromString("leading-zero-neg = -03.14\n"))
assert Result.isErr(fromString("leading-zero-plus = +03.14\n"))
assert Result.isErr(fromString("leading-zero = 03.14\n"))
assert Result.isErr(fromString("v = NaN\n"))
assert Result.isErr(fromString("nan-incomplete-1 = na\n"))
assert Result.isErr(fromString("nan-incomplete-2 = +na\n"))
assert Result.isErr(fromString("nan-incomplete-3 = -na\n"))
assert Result.isErr(fromString("nan_underscore = na_n\n"))
assert Result.isErr(fromString("trailing-point-min = -1.\n"))
assert Result.isErr(fromString("trailing-point-plus = +1.\n"))
assert Result.isErr(fromString("trailing-point = 1.\n"))
assert Result.isErr(
  fromString(
    "# trailing underscore in integer part is not allowed\ntrailing-us-exp = 1_e2\n# trailing underscore in float part is not allowed\ntrailing-us-exp2 = 1.2_e2\n"
  )
)
assert Result.isErr(fromString("trailing-us = 1.2_\n"))
assert Result.isErr(fromString("us-after-point = 1._2\n"))
assert Result.isErr(fromString("us-before-point = 1_.2\n"))

// encoding
assert Result.isErr(fromString("# Invalid codepoint U+D800 : ���\n"))
assert Result.isErr(
  fromString(
    "# There is a 0xda at after the quotes, and no EOL at the end of the file.\n#\n# This is a bit of an edge case: This indicates there should be two bytes\n# (0b1101_1010) but there is no byte to follow because it's the end of the file.\nx = \"\"\"\"\"\"�"
  )
)
assert Result.isErr(fromString("# �\n"))
assert Result.isErr(
  fromString(
    "# The following line contains an invalid UTF-8 sequence.\nbad = '''�'''\n"
  )
)
assert Result.isErr(
  fromString(
    "# The following line contains an invalid UTF-8 sequence.\nbad = \"\"\"�\"\"\"\n"
  )
)
assert Result.isErr(
  fromString(
    "# The following line contains an invalid UTF-8 sequence.\nbad = '�'\n"
  )
)
assert Result.isErr(
  fromString(
    "# The following line contains an invalid UTF-8 sequence.\nbad = \"�\"\n"
  )
)
assert Result.isErr(fromString("bom-not-at-start ��\n"))
assert Result.isErr(fromString("bom-not-at-start= ��\n"))
assert Result.isErr(fromString("�� #   U T F - 1 6   w i t h   B O M \n"))
assert Result.isErr(fromString(" #   U T F - 1 6   w i t h o u t   B O M \n"))

// datetime
assert Result.isErr(
  fromString(
    "# time-hour       = 2DIGIT  ; 00-23\nd = 2006-01-01T24:00:00-00:00\n"
  )
)
assert Result.isErr(
  fromString(
    "# date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on\n#                           ; month/year\nd = 2006-01-32T00:00:00-00:00\n"
  )
)
assert Result.isErr(
  fromString(
    "# date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on\n#                           ; month/year\nd = 2006-01-00T00:00:00-00:00\n"
  )
)
assert Result.isErr(
  fromString(
    "# time-minute     = 2DIGIT  ; 00-59\nd = 2006-01-01T00:60:00-00:00\n"
  )
)
assert Result.isErr(
  fromString(
    "# date-month      = 2DIGIT  ; 01-12\nd = 2006-13-01T00:00:00-00:00\n"
  )
)
assert Result.isErr(
  fromString(
    "# date-month      = 2DIGIT  ; 01-12\nd = 2007-00-01T00:00:00-00:00\n"
  )
)
assert Result.isErr(
  fromString(
    "# Day \"5\" instead of \"05\"; the leading zero is required.\nwith-milli = 1987-07-5T17:45:00.12Z\n"
  )
)
assert Result.isErr(
  fromString(
    "# Month \"7\" instead of \"07\"; the leading zero is required.\nno-leads = 1987-7-05T17:45:00Z\n"
  )
)
assert Result.isErr(
  fromString(
    "# No \"t\" or \"T\" between the date and time.\nno-t = 1987-07-0517:45:00Z\n"
  )
)
// assert Result.isErr(
//   fromString(
//     "# time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second\n#                           ; rules\nd = 2006-01-01T00:00:61-00:00\n"
//   )
// )
assert Result.isErr(
  fromString("# Leading 0 is always required.\nd = 01:32:0\n")
)
assert Result.isErr(
  fromString("# Leading 0 is always required.\nd = 1:32:00\n")
)
assert Result.isErr(
  fromString("# Date cannot end with trailing T\nd = 2006-01-30T\n")
)

// control
assert Result.isErr(
  fromString(
    "# The following line contains a single carriage return control character\r\n\r"
  )
)
assert Result.isErr(fromString("bare-formfeed = \n"))
assert Result.isErr(fromString("bare-null = \"some value\"  \n"))
assert Result.isErr(fromString("bare-vertical-tab = \n"))
assert Result.isErr(
  fromString("comment-cr = \"Carriage return in comment\" # \ra=1\n")
)
assert Result.isErr(fromString("multi-del = \"\"\"null\"\"\"\n"))
assert Result.isErr(fromString("multi-lf = \"\"\"null\"\"\"\n"))
assert Result.isErr(fromString("multi-null = \"\"\"null \"\"\"\n"))
assert Result.isErr(fromString("multi-us = \"\"\"null\"\"\"\n"))
assert Result.isErr(fromString("rawmulti-del = '''null'''\n"))
assert Result.isErr(fromString("rawmulti-lf = '''null'''\n"))
assert Result.isErr(fromString("rawmulti-null = '''null '''\n"))
assert Result.isErr(fromString("rawmulti-us = '''null'''\n"))
assert Result.isErr(fromString("rawstring-del = 'null'\n"))
assert Result.isErr(fromString("rawstring-lf = 'null'\n"))
assert Result.isErr(fromString("rawstring-null = 'null '\n"))
assert Result.isErr(fromString("rawstring-us = 'null'\n"))
assert Result.isErr(fromString("string-bs = \"backspace\"\n"))
assert Result.isErr(fromString("string-del = \"null\"\n"))
assert Result.isErr(fromString("string-lf = \"null\"\n"))
assert Result.isErr(fromString("string-null = \"null \"\n"))
assert Result.isErr(fromString("string-us = \"null\"\n"))

// bool
assert Result.isErr(fromString("a = falsify\n"))
assert Result.isErr(fromString("a = fals\n"))
assert Result.isErr(fromString("a = truthy\n"))
assert Result.isErr(fromString("a = tru\n"))
assert Result.isErr(fromString("a = f\n"))
assert Result.isErr(fromString("a = t\n"))
assert Result.isErr(fromString("valid = False\n"))
assert Result.isErr(fromString("a = falsey\n"))
assert Result.isErr(fromString("a = truer\n"))
assert Result.isErr(fromString("b = FALSE\n"))
assert Result.isErr(fromString("a = TRUE\n"))

// array
assert Result.isErr(fromString("array = [1,,2]\n"))
assert Result.isErr(fromString("array = [1,2,,]\n\n"))
assert Result.isErr(
  fromString(
    "a = [{ b = 1 }]\n\n# Cannot extend tables within static arrays\n# https://github.com/toml-lang/toml/issues/908\n[a.c]\nfoo = 1\n"
  )
)
assert Result.isErr(fromString("wrong = [ 1 2 3 ]\n"))
assert Result.isErr(fromString("x = [42 #\n"))
assert Result.isErr(fromString("x = [{ key = 42 #\n"))
assert Result.isErr(fromString("x = [{ key = 42\n"))
assert Result.isErr(fromString("long_array = [ 1, 2, 3\n"))
assert Result.isErr(
  fromString("# INVALID TOML DOC\nfruit = []\n\n[[fruit]] # Not allowed\n")
)
assert Result.isErr(
  fromString(
    "# INVALID TOML DOC\n[[fruit]]\n  name = \"apple\"\n\n  [[fruit.variety]]\n    name = \"red delicious\"\n\n  # This table conflicts with the previous table\n  [fruit.variety]\n    name = \"granny smith\"\n"
  )
)
assert Result.isErr(
  fromString(
    "array = [\n  \"Is there life after an array separator?\", No\n  \"Entry\"\n]\n"
  )
)
assert Result.isErr(
  fromString(
    "array = [\n  \"Is there life before an array separator?\" No,\n  \"Entry\"\n]\n"
  )
)
assert Result.isErr(
  fromString(
    "array = [\n  \"Entry 1\",\n  I don't belong,\n  \"Entry 2\",\n]\n"
  )
)

// Valid Tests

// valid
assert sortToml(
  fromString(
    "# This is a TOML document. Boom.\n\ntitle = \"TOML Example\"\n\n[owner]\nname = \"Lance Uppercut\"\ndob = 1979-05-27T07:32:00-08:00 # First class dates? Why not?\n\n[database]\nserver = \"192.168.1.1\"\nports = [ 8001, 8001, 8002 ]\nconnection_max = 5000\nenabled = true\n\n[servers]\n\n  # You can indent as you please. Tabs or spaces. TOML don't care.\n  [servers.alpha]\n  ip = \"10.0.0.1\"\n  dc = \"eqdc10\"\n\n  [servers.beta]\n  ip = \"10.0.0.2\"\n  dc = \"eqdc10\"\n\n[clients]\ndata = [ [\"gamma\", \"delta\"], [1, 2] ]\n\n# Line breaks are OK when inside arrays\nhosts = [\n  \"alpha\",\n  \"omega\"\n]\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "clients",
            TomlTable(
              [
                (
                  "data",
                  TomlArray(
                    [
                      TomlArray([TomlString("gamma"), TomlString("delta")]),
                      TomlArray([TomlInt(1), TomlInt(2)]),
                    ]
                  ),
                ),
                (
                  "hosts",
                  TomlArray([TomlString("alpha"), TomlString("omega")]),
                ),
              ]
            ),
          ),
          (
            "database",
            TomlTable(
              [
                ("connection_max", TomlInt(5000)),
                ("enabled", TomlBool(true)),
                (
                  "ports",
                  TomlArray([TomlInt(8001), TomlInt(8001), TomlInt(8002)]),
                ),
                ("server", TomlString("192.168.1.1")),
              ]
            ),
          ),
          (
            "owner",
            TomlTable(
              [
                ("dob", TomlDateTime("1979-05-27T07:32:00-08:00")),
                ("name", TomlString("Lance Uppercut")),
              ]
            ),
          ),
          (
            "servers",
            TomlTable(
              [
                (
                  "alpha",
                  TomlTable(
                    [
                      ("dc", TomlString("eqdc10")),
                      ("ip", TomlString("10.0.0.1")),
                    ]
                  ),
                ),
                (
                  "beta",
                  TomlTable(
                    [
                      ("dc", TomlString("eqdc10")),
                      ("ip", TomlString("10.0.0.2")),
                    ]
                  ),
                ),
              ]
            ),
          ),
          ("title", TomlString("TOML Example")),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "#Useless spaces eliminated.\ntitle=\"TOML Example\"\n[owner]\nname=\"Lance Uppercut\"\ndob=1979-05-27T07:32:00-08:00#First class dates\n[database]\nserver=\"192.168.1.1\"\nports=[8001,8001,8002]\nconnection_max=5000\nenabled=true\n[servers]\n[servers.alpha]\nip=\"10.0.0.1\"\ndc=\"eqdc10\"\n[servers.beta]\nip=\"10.0.0.2\"\ndc=\"eqdc10\"\n[clients]\ndata=[[\"gamma\",\"delta\"],[1,2]]\nhosts=[\n\"alpha\",\n\"omega\"\n]\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "clients",
            TomlTable(
              [
                (
                  "data",
                  TomlArray(
                    [
                      TomlArray([TomlString("gamma"), TomlString("delta")]),
                      TomlArray([TomlInt(1), TomlInt(2)]),
                    ]
                  ),
                ),
                (
                  "hosts",
                  TomlArray([TomlString("alpha"), TomlString("omega")]),
                ),
              ]
            ),
          ),
          (
            "database",
            TomlTable(
              [
                ("connection_max", TomlInt(5000)),
                ("enabled", TomlBool(true)),
                (
                  "ports",
                  TomlArray([TomlInt(8001), TomlInt(8001), TomlInt(8002)]),
                ),
                ("server", TomlString("192.168.1.1")),
              ]
            ),
          ),
          (
            "owner",
            TomlTable(
              [
                ("dob", TomlDateTime("1979-05-27T07:32:00-08:00")),
                ("name", TomlString("Lance Uppercut")),
              ]
            ),
          ),
          (
            "servers",
            TomlTable(
              [
                (
                  "alpha",
                  TomlTable(
                    [
                      ("dc", TomlString("eqdc10")),
                      ("ip", TomlString("10.0.0.1")),
                    ]
                  ),
                ),
                (
                  "beta",
                  TomlTable(
                    [
                      ("dc", TomlString("eqdc10")),
                      ("ip", TomlString("10.0.0.2")),
                    ]
                  ),
                ),
              ]
            ),
          ),
          ("title", TomlString("TOML Example")),
        ]
      )
    )
  )
assert sortToml(fromString("os = \"unix\"\nnewline = \"lf\"\n")) ==
  sortToml(
    Ok(TomlTable([("newline", TomlString("lf")), ("os", TomlString("unix"))]))
  )
assert sortToml(fromString("os = \"DOS\"\r\nnewline = \"crlf\"\r\n")) ==
  sortToml(
    Ok(TomlTable([("newline", TomlString("crlf")), ("os", TomlString("DOS"))]))
  )
assert sortToml(fromString("[a.b.c]\nanswer = 42\n")) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "a",
            TomlTable(
              [("b", TomlTable([("c", TomlTable([("answer", TomlInt(42))]))]))]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(fromString("[a]\nbetter = 43\n\n[a.b.c]\nanswer = 42\n")) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "a",
            TomlTable(
              [
                ("b", TomlTable([("c", TomlTable([("answer", TomlInt(42))]))])),
                ("better", TomlInt(43)),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(fromString("[a.b.c]\nanswer = 42\n\n[a]\nbetter = 43\n")) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "a",
            TomlTable(
              [
                ("b", TomlTable([("c", TomlTable([("answer", TomlInt(42))]))])),
                ("better", TomlInt(43)),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "best-day-ever = 1987-07-05T17:45:00Z\n\n[numtheory]\nboring = false\nperfection = [6, 28, 496]\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("best-day-ever", TomlDateTime("1987-07-05T17:45:00Z")),
          (
            "numtheory",
            TomlTable(
              [
                ("boring", TomlBool(false)),
                (
                  "perfection",
                  TomlArray([TomlInt(6), TomlInt(28), TomlInt(496)]),
                ),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(fromString("")) == sortToml(Ok(TomlTable([])))

// table
// assert sortToml(fromString("[[a.b]]\nx = 1\n\n[a]\ny = 2\n")) ==
//   sortToml(
//     Ok(
//       TomlTable(
//         [
//           (
//             "a",
//             TomlTable(
//               [
//                 ("b", TomlArray([TomlTable([("x", TomlInt(1))])])),
//                 ("y", TomlInt(2)),
//               ]
//             ),
//           ),
//         ]
//       )
//     )
//   )
// assert sortToml(fromString("[[albums.songs]]\nname = \"Glory Days\"\n")) ==
//   sortToml(
//     Ok(
//       TomlTable(
//         [
//           (
//             "albums",
//             TomlTable(
//               [
//                 (
//                   "songs",
//                   TomlArray([TomlTable([("name", TomlString("Glory Days"))])]),
//                 ),
//               ]
//             ),
//           ),
//         ]
//       )
//     )
//   )
// assert sortToml(
//   fromString(
//     "[[people]]\nfirst_name = \"Bruce\"\nlast_name = \"Springsteen\"\n\n[[people]]\nfirst_name = \"Eric\"\nlast_name = \"Clapton\"\n\n[[people]]\nfirst_name = \"Bob\"\nlast_name = \"Seger\"\n"
//   )
// ) ==
//   sortToml(
//     Ok(
//       TomlTable(
//         [
//           (
//             "people",
//             TomlArray(
//               [
//                 TomlTable(
//                   [
//                     ("first_name", TomlString("Bruce")),
//                     ("last_name", TomlString("Springsteen")),
//                   ]
//                 ),
//                 TomlTable(
//                   [
//                     ("first_name", TomlString("Eric")),
//                     ("last_name", TomlString("Clapton")),
//                   ]
//                 ),
//                 TomlTable(
//                   [
//                     ("first_name", TomlString("Bob")),
//                     ("last_name", TomlString("Seger")),
//                   ]
//                 ),
//               ]
//             ),
//           ),
//         ]
//       )
//     )
//   )
// assert sortToml(
//   fromString(
//     "[[albums]]\nname = \"Born to Run\"\n\n  [[albums.songs]]\n  name = \"Jungleland\"\n\n  [[albums.songs]]\n  name = \"Meeting Across the River\"\n\n[[albums]]\nname = \"Born in the USA\"\n  \n  [[albums.songs]]\n  name = \"Glory Days\"\n\n  [[albums.songs]]\n  name = \"Dancing in the Dark\"\n"
//   )
// ) ==
//   sortToml(
//     Ok(
//       TomlTable(
//         [
//           (
//             "albums",
//             TomlArray(
//               [
//                 TomlTable(
//                   [
//                     ("name", TomlString("Born to Run")),
//                     (
//                       "songs",
//                       TomlArray(
//                         [
//                           TomlTable([("name", TomlString("Jungleland"))]),
//                           TomlTable(
//                             [("name", TomlString("Meeting Across the River"))]
//                           ),
//                         ]
//                       ),
//                     ),
//                   ]
//                 ),
//                 TomlTable(
//                   [
//                     ("name", TomlString("Born in the USA")),
//                     (
//                       "songs",
//                       TomlArray(
//                         [
//                           TomlTable([("name", TomlString("Glory Days"))]),
//                           TomlTable(
//                             [("name", TomlString("Dancing in the Dark"))]
//                           ),
//                         ]
//                       ),
//                     ),
//                   ]
//                 ),
//               ]
//             ),
//           ),
//         ]
//       )
//     )
//   )
// assert sortToml(
//   fromString(
//     "[[people]]\nfirst_name = \"Bruce\"\nlast_name = \"Springsteen\"\n"
//   )
// ) ==
//   sortToml(
//     Ok(
//       TomlTable(
//         [
//           (
//             "people",
//             TomlArray(
//               [
//                 TomlTable(
//                   [
//                     ("first_name", TomlString("Bruce")),
//                     ("last_name", TomlString("Springsteen")),
//                   ]
//                 ),
//               ]
//             ),
//           ),
//         ]
//       )
//     )
//   )
// assert sortToml(
//   fromString(
//     "[[a]]\n    [[a.b]]\n        [a.b.c]\n            d = \"val0\"\n    [[a.b]]\n        [a.b.c]\n            d = \"val1\"\n"
//   )
// ) ==
//   sortToml(
//     Ok(
//       TomlTable(
//         [
//           (
//             "a",
//             TomlArray(
//               [
//                 TomlTable(
//                   [
//                     (
//                       "b",
//                       TomlArray(
//                         [
//                           TomlTable(
//                             [("c", TomlTable([("d", TomlString("val0"))]))]
//                           ),
//                           TomlTable(
//                             [("c", TomlTable([("d", TomlString("val1"))]))]
//                           ),
//                         ]
//                       ),
//                     ),
//                   ]
//                 ),
//               ]
//             ),
//           ),
//         ]
//       )
//     )
//   )
// assert sortToml(
//   fromString(
//     "[fruit]\napple.color = \"red\"\n\n[[fruit.apple.seeds]]\nsize = 2\n"
//   )
// ) ==
//   sortToml(
//     Ok(
//       TomlTable(
//         [
//           (
//             "fruit",
//             TomlTable(
//               [
//                 (
//                   "apple",
//                   TomlTable(
//                     [
//                       ("color", TomlString("red")),
//                       ("seeds", TomlArray([TomlTable([("size", TomlInt(2))])])),
//                     ]
//                   ),
//                 ),
//               ]
//             ),
//           ),
//         ]
//       )
//     )
//   )
// assert sortToml(
//   fromString("['']\nx = 1\n\n[\"\".a]\nx = 2\n\n[a.'']\nx = 3\n")
// ) ==
//   sortToml(
//     Ok(
//       TomlTable(
//         [
//           (
//             "",
//             TomlTable(
//               [("x", TomlInt(1)), ("a", TomlTable([("x", TomlInt(2))]))]
//             ),
//           ),
//           ("a", TomlTable([("", TomlTable([("x", TomlInt(3))]))])),
//         ]
//       )
//     )
//   )
assert sortToml(fromString("[a]\n")) ==
  sortToml(Ok(TomlTable([("a", TomlTable([]))])))
assert sortToml(fromString("[true]\n\n[false]\n\n[inf]\n\n[nan]\n\n\n")) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("true", TomlTable([])),
          ("false", TomlTable([])),
          ("inf", TomlTable([])),
          ("nan", TomlTable([])),
        ]
      )
    )
  )
// assert sortToml(
//   fromString(
//     "[a.b.c]\n[a.\"b.c\"]\n[a.'d.e']\n[a.' x ']\n[ d.e.f ]\n[ g . h . i ]\n[ j . \"ʞ\" . 'l' ]\n\n[x.1.2]\n"
//   )
// ) ==
//   sortToml(
//     Ok(
//       TomlTable(
//         [
//           (
//             "a",
//             TomlTable(
//               [
//                 (" x ", TomlTable([])),
//                 ("b", TomlTable([("c", TomlTable([]))])),
//                 ("b.c", TomlTable([])),
//                 ("d.e", TomlTable([])),
//               ]
//             ),
//           ),
//           ("d", TomlTable([("e", TomlTable([("f", TomlTable([]))]))])),
//           ("g", TomlTable([("h", TomlTable([("i", TomlTable([]))]))])),
//           ("j", TomlTable([("ʞ", TomlTable([("l", TomlTable([]))]))])),
//           ("x", TomlTable([("1", TomlTable([("2", TomlTable([]))]))])),
//         ]
//       )
//     )
//   )
assert sortToml(fromString("[table]\n")) ==
  sortToml(Ok(TomlTable([("table", TomlTable([]))])))
assert sortToml(fromString("[a]\n[a.b]\n")) ==
  sortToml(Ok(TomlTable([("a", TomlTable([("b", TomlTable([]))]))])))
assert sortToml(
  fromString(
    "[a]\nkey = 1\n\n# a.extend is a key inside the \"a\" table.\n[a.extend]\nkey = 2\n\n[a.extend.more]\nkey = 3\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "a",
            TomlTable(
              [
                (
                  "extend",
                  TomlTable(
                    [
                      ("key", TomlInt(2)),
                      ("more", TomlTable([("key", TomlInt(3))])),
                    ]
                  ),
                ),
                ("key", TomlInt(1)),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(fromString("[\"valid key\"]\n")) ==
  sortToml(Ok(TomlTable([("valid key", TomlTable([]))])))
assert sortToml(
  fromString("['a']\n[a.'\"b\"']\n[a.'\"b\"'.c]\nanswer = 42 \n")
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "a",
            TomlTable(
              [
                (
                  "\"b\"",
                  TomlTable([("c", TomlTable([("answer", TomlInt(42))]))]),
                ),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(fromString("[\"key#group\"]\nanswer = 42\n")) ==
  sortToml(Ok(TomlTable([("key#group", TomlTable([("answer", TomlInt(42))]))])))
assert sortToml(fromString("['a']\n[a.'b']\n[a.'b'.c]\nanswer = 42 \n")) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "a",
            TomlTable(
              [("b", TomlTable([("c", TomlTable([("answer", TomlInt(42))]))]))]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "# [x] you\n# [x.y] don't\n# [x.y.z] need these\n[x.y.z.w] # for this to work\n[x] # defining a super-table afterwards is ok\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "x",
            TomlTable(
              [("y", TomlTable([("z", TomlTable([("w", TomlTable([]))]))]))]
            ),
          ),
        ]
      )
    )
  )

// string
assert sortToml(fromString("test = \"\\\"one\\\"\"\n")) ==
  sortToml(Ok(TomlTable([("test", TomlString("\"one\""))])))
assert sortToml(fromString("answer = \"\"\n")) ==
  sortToml(Ok(TomlTable([("answer", TomlString(""))])))
assert sortToml(fromString("esc = \"\\e There is no escape! \\e\"\n")) ==
  sortToml(Ok(TomlTable([("esc", TomlString(" There is no escape! "))])))
assert sortToml(
  fromString(
    "end_esc = \"String does not end here\\\" but ends here\\\\\"\nlit_end_esc = 'String ends here\\'\n\nmultiline_unicode = \"\"\"\n\\u00a0\"\"\"\n\nmultiline_not_unicode = \"\"\"\n\\\\u0041\"\"\"\n\nmultiline_end_esc = \"\"\"When will it end? \\\"\"\"...\"\"\\\" should be here\\\"\"\"\"\n\nlit_multiline_not_unicode = '''\n\\u007f'''\n\nlit_multiline_end = '''There is no escape\\'''\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("end_esc", TomlString("String does not end here\" but ends here\\")),
          ("lit_end_esc", TomlString("String ends here\\")),
          ("lit_multiline_end", TomlString("There is no escape\\")),
          ("lit_multiline_not_unicode", TomlString("\\u007f")),
          (
            "multiline_end_esc",
            TomlString("When will it end? \"\"\"...\"\"\" should be here\""),
          ),
          ("multiline_not_unicode", TomlString("\\u0041")),
          ("multiline_unicode", TomlString(" ")),
        ]
      )
    )
  )
assert sortToml(fromString("answer = \"\\\\x64\"\n")) ==
  sortToml(Ok(TomlTable([("answer", TomlString("\\x64"))])))
assert sortToml(
  fromString(
    "backspace = \"This string has a \\b backspace character.\"\ntab = \"This string has a \\t tab character.\"\nnewline = \"This string has a \\n new line character.\"\nformfeed = \"This string has a \\f form feed character.\"\ncarriage = \"This string has a \\r carriage return character.\"\nquote = \"This string has a \\\" quote character.\"\nbackslash = \"This string has a \\\\ backslash character.\"\nnotunicode1 = \"This string does not have a unicode \\\\u escape.\"\nnotunicode2 = \"This string does not have a unicode \\u005Cu escape.\"\nnotunicode3 = \"This string does not have a unicode \\\\u0075 escape.\"\nnotunicode4 = \"This string does not have a unicode \\\\\\u0075 escape.\"\ndelete = \"This string has a \\u007F delete control code.\"\nunitseparator = \"This string has a \\u001F unit separator control code.\"\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "backslash",
            TomlString("This string has a \\ backslash character."),
          ),
          ("backspace", TomlString("This string has a  backspace character.")),
          (
            "carriage",
            TomlString("This string has a \r carriage return character."),
          ),
          ("delete", TomlString("This string has a  delete control code.")),
          ("formfeed", TomlString("This string has a  form feed character.")),
          ("newline", TomlString("This string has a \n new line character.")),
          (
            "notunicode1",
            TomlString("This string does not have a unicode \\u escape."),
          ),
          (
            "notunicode2",
            TomlString("This string does not have a unicode \\u escape."),
          ),
          (
            "notunicode3",
            TomlString("This string does not have a unicode \\u0075 escape."),
          ),
          (
            "notunicode4",
            TomlString("This string does not have a unicode \\u escape."),
          ),
          ("quote", TomlString("This string has a \" quote character.")),
          ("tab", TomlString("This string has a \t tab character.")),
          (
            "unitseparator",
            TomlString("This string has a  unit separator control code."),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "# \\x for the first 255 codepoints\n\nwhitespace      = \"\\x20 \\x09 \\x1b \\x0d\\x0a\"\nbs              = \"\\x7f\"\nnul             = \"\\x00\"\nhello           = \"\\x68\\x65\\x6c\\x6c\\x6f\\x0a\"\nhigher-than-127 = \"S\\xf8rmirb\\xe6ren\"\n\nmultiline = \"\"\"\n\\x20 \\x09 \\x1b \\x0d\\x0a\n\\x7f\n\\x00\n\\x68\\x65\\x6c\\x6c\\x6f\\x0a\n\\x53\\xF8\\x72\\x6D\\x69\\x72\\x62\\xE6\\x72\\x65\\x6E\n\"\"\"\n\n# Not inside literals.\nliteral = '\\x20 \\x09 \\x0d\\x0a'\nmultiline-literal = '''\n\\x20 \\x09 \\x0d\\x0a\n'''\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("bs", TomlString("")),
          ("hello", TomlString("hello\n")),
          ("higher-than-127", TomlString("Sørmirbæren")),
          ("literal", TomlString("\\x20 \\x09 \\x0d\\x0a")),
          (
            "multiline",
            TomlString("  \t  \r\n\n\n \nhello\n\nSørmirbæren\n"),
          ),
          ("multiline-literal", TomlString("\\x20 \\x09 \\x0d\\x0a\n")),
          ("nul", TomlString(" ")),
          ("whitespace", TomlString("  \t  \r\n")),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "# The following line should be an unescaped backslash followed by a Windows\r\n# newline sequence (\"\\r\\n\")\r\n0=\"\"\"\\\r\n\"\"\"\r\n"
  )
) ==
  sortToml(Ok(TomlTable([("0", TomlString(""))])))
assert sortToml(
  fromString(
    "# Make sure that quotes inside multiline strings are allowed, including right\n# after the opening '''/\"\"\" and before the closing '''/\"\"\"\n\nlit_one = ''''one quote''''\nlit_two = '''''two quotes'''''\nlit_one_space = ''' 'one quote' '''\nlit_two_space = ''' ''two quotes'' '''\n\none = \"\"\"\"one quote\"\"\"\"\ntwo = \"\"\"\"\"two quotes\"\"\"\"\"\none_space = \"\"\" \"one quote\" \"\"\"\ntwo_space = \"\"\" \"\"two quotes\"\" \"\"\"\n\nmismatch1 = \"\"\"aaa'''bbb\"\"\"\nmismatch2 = '''aaa\"\"\"bbb'''\n\n# Three opening \"\"\", then one escaped \", then two \"\" (allowed), and then three\n# closing \"\"\"\nescaped = \"\"\"lol\\\"\"\"\"\"\"\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("escaped", TomlString("lol\"\"\"")),
          ("lit_one", TomlString("'one quote'")),
          ("lit_one_space", TomlString(" 'one quote' ")),
          ("lit_two", TomlString("''two quotes''")),
          ("lit_two_space", TomlString(" ''two quotes'' ")),
          ("mismatch1", TomlString("aaa'''bbb")),
          ("mismatch2", TomlString("aaa\"\"\"bbb")),
          ("one", TomlString("\"one quote\"")),
          ("one_space", TomlString(" \"one quote\" ")),
          ("two", TomlString("\"\"two quotes\"\"")),
          ("two_space", TomlString(" \"\"two quotes\"\" ")),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "# NOTE: this file includes some literal tab characters.\n\nmultiline_empty_one = \"\"\"\"\"\"\n\n# A newline immediately following the opening delimiter will be trimmed.\nmultiline_empty_two = \"\"\"\n\"\"\"\n\n# \\ at the end of line trims newlines as well; note that last \\ is followed by\n# two spaces, which are ignored.\nmultiline_empty_three = \"\"\"\\\n    \"\"\"\nmultiline_empty_four = \"\"\"\\\n   \\\n   \\  \n   \"\"\"\n\nequivalent_one = \"The quick brown fox jumps over the lazy dog.\"\nequivalent_two = \"\"\"\nThe quick brown \\\n\n\n  fox jumps over \\\n    the lazy dog.\"\"\"\n\nequivalent_three = \"\"\"\\\n       The quick brown \\\n       fox jumps over \\\n       the lazy dog.\\\n       \"\"\"\n\nwhitespace-after-bs = \"\"\"\\\n       The quick brown \\\n       fox jumps over \\   \n       the lazy dog.\\\t\n       \"\"\"\n\nno-space = \"\"\"a\\\n    b\"\"\"\n\n# Has tab character.\nkeep-ws-before = \"\"\"a   \t\\\n   b\"\"\"\n\nescape-bs-1 = \"\"\"a \\\\\nb\"\"\"\n\nescape-bs-2 = \"\"\"a \\\\\\\nb\"\"\"\n\nescape-bs-3 = \"\"\"a \\\\\\\\\n  b\"\"\"\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "equivalent_one",
            TomlString("The quick brown fox jumps over the lazy dog."),
          ),
          (
            "equivalent_three",
            TomlString("The quick brown fox jumps over the lazy dog."),
          ),
          (
            "equivalent_two",
            TomlString("The quick brown fox jumps over the lazy dog."),
          ),
          ("escape-bs-1", TomlString("a \\\nb")),
          ("escape-bs-2", TomlString("a \\b")),
          ("escape-bs-3", TomlString("a \\\\\n  b")),
          ("keep-ws-before", TomlString("a   \tb")),
          ("multiline_empty_four", TomlString("")),
          ("multiline_empty_one", TomlString("")),
          ("multiline_empty_three", TomlString("")),
          ("multiline_empty_two", TomlString("")),
          ("no-space", TomlString("ab")),
          (
            "whitespace-after-bs",
            TomlString("The quick brown fox jumps over the lazy dog."),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "nl_mid = \"val\\nue\"\nnl_end = \"\"\"value\\n\"\"\"\n\nlit_nl_end = '''value\\n'''\nlit_nl_mid = 'val\\nue'\nlit_nl_uni = 'val\\ue'\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("lit_nl_end", TomlString("value\\n")),
          ("lit_nl_mid", TomlString("val\\nue")),
          ("lit_nl_uni", TomlString("val\\ue")),
          ("nl_end", TomlString("value\n")),
          ("nl_mid", TomlString("val\nue")),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "\nescaped_string = \"\\u0000 \\u0008 \\u000c \\U00000041 \\u007f \\u0080 \\u00ff \\ud7ff \\ue000 \\uffff \\U00010000 \\U0010ffff\"\nnot_escaped_string = '\\u0000 \\u0008 \\u000c \\U00000041 \\u007f \\u0080 \\u00ff \\ud7ff \\ue000 \\uffff \\U00010000 \\U0010ffff'\n\nbasic_string = \"~  ÿ ퟿  ￿ 𐀀 􏿿\"\nliteral_string = '~  ÿ ퟿  ￿ 𐀀 􏿿'\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "escaped_string",
            TomlString("    A   ÿ ퟿  ￿ 𐀀 􏿿"),
          ),
          (
            "not_escaped_string",
            TomlString(
              "\\u0000 \\u0008 \\u000c \\U00000041 \\u007f \\u0080 \\u00ff \\ud7ff \\ue000 \\uffff \\U00010000 \\U0010ffff"
            ),
          ),
          ("basic_string", TomlString("~  ÿ ퟿  ￿ 𐀀 􏿿")),
          ("literal_string", TomlString("~  ÿ ퟿  ￿ 𐀀 􏿿")),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "# Single ' should be allowed.\noneline = '''This string has a ' quote character.'''\n\n# A newline immediately following the opening delimiter will be trimmed.\nfirstnl = '''\nThis string has a ' quote character.'''\n\n# All other whitespace and newline characters remain intact.\nmultiline = '''\nThis string\nhas ' a quote character\nand more than\none newline\nin it.'''\n\n# Tab character in literal string does not need to be escaped\nmultiline_with_tab = '''First line\n\t Followed by a tab'''\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("firstnl", TomlString("This string has a ' quote character.")),
          (
            "multiline",
            TomlString(
              "This string\nhas ' a quote character\nand more than\none newline\nin it."
            ),
          ),
          ("oneline", TomlString("This string has a ' quote character.")),
          (
            "multiline_with_tab",
            TomlString("First line\n\t Followed by a tab"),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "backspace = 'This string has a \\b backspace character.'\ntab = 'This string has a \\t tab character.'\nunescaped_tab = 'This string has an \t unescaped tab character.'\nnewline = 'This string has a \\n new line character.'\nformfeed = 'This string has a \\f form feed character.'\ncarriage = 'This string has a \\r carriage return character.'\nslash = 'This string has a \\/ slash character.'\nbackslash = 'This string has a \\\\ backslash character.'\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "backslash",
            TomlString("This string has a \\\\ backslash character."),
          ),
          (
            "backspace",
            TomlString("This string has a \\b backspace character."),
          ),
          (
            "carriage",
            TomlString("This string has a \\r carriage return character."),
          ),
          (
            "formfeed",
            TomlString("This string has a \\f form feed character."),
          ),
          ("newline", TomlString("This string has a \\n new line character.")),
          ("slash", TomlString("This string has a \\/ slash character.")),
          ("tab", TomlString("This string has a \\t tab character.")),
          (
            "unescaped_tab",
            TomlString("This string has an \t unescaped tab character."),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString("answer = \"You are not drinking enough whisky.\"\n")
) ==
  sortToml(
    Ok(
      TomlTable([("answer", TomlString("You are not drinking enough whisky."))])
    )
  )
assert sortToml(
  fromString("answer4 = \"\\u03B4\"\nanswer8 = \"\\U000003B4\"\n")
) ==
  sortToml(
    Ok(
      TomlTable([("answer4", TomlString("δ")), ("answer8", TomlString("δ"))])
    )
  )
assert sortToml(fromString("answer = \"δ\"\n")) ==
  sortToml(Ok(TomlTable([("answer", TomlString("δ"))])))
assert sortToml(
  fromString(
    "pound = \"We see no # comments here.\"\npoundcomment = \"But there are # some comments here.\" # Did I # mess you up?\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("pound", TomlString("We see no # comments here.")),
          ("poundcomment", TomlString("But there are # some comments here.")),
        ]
      )
    )
  )

// spec
assert sortToml(
  fromString(
    "integers = [ 1, 2, 3 ]\ncolors = [ \"red\", \"yellow\", \"green\" ]\nnested_arrays_of_ints = [ [ 1, 2 ], [3, 4, 5] ]\nnested_mixed_array = [ [ 1, 2 ], [\"a\", \"b\", \"c\"] ]\nstring_array = [ \"all\", 'strings', \"\"\"are the same\"\"\", '''type''' ]\n\n# Mixed-type arrays are allowed\nnumbers = [ 0.1, 0.2, 0.5, 1, 2, 5 ]\ncontributors = [\n  \"Foo Bar <foo@example.com>\",\n  { name = \"Baz Qux\", email = \"bazqux@example.com\", url = \"https://example.com/bazqux\" }\n]\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "colors",
            TomlArray(
              [TomlString("red"), TomlString("yellow"), TomlString("green")]
            ),
          ),
          (
            "contributors",
            TomlArray(
              [
                TomlString("Foo Bar <foo@example.com>"),
                TomlTable(
                  [
                    ("email", TomlString("bazqux@example.com")),
                    ("name", TomlString("Baz Qux")),
                    ("url", TomlString("https://example.com/bazqux")),
                  ]
                ),
              ]
            ),
          ),
          ("integers", TomlArray([TomlInt(1), TomlInt(2), TomlInt(3)])),
          (
            "nested_arrays_of_ints",
            TomlArray(
              [
                TomlArray([TomlInt(1), TomlInt(2)]),
                TomlArray([TomlInt(3), TomlInt(4), TomlInt(5)]),
              ]
            ),
          ),
          (
            "nested_mixed_array",
            TomlArray(
              [
                TomlArray([TomlInt(1), TomlInt(2)]),
                TomlArray([TomlString("a"), TomlString("b"), TomlString("c")]),
              ]
            ),
          ),
          (
            "numbers",
            TomlArray(
              [
                TomlFloat(0.1),
                TomlFloat(0.2),
                TomlFloat(0.5),
                TomlInt(1),
                TomlInt(2),
                TomlInt(5),
              ]
            ),
          ),
          (
            "string_array",
            TomlArray(
              [
                TomlString("all"),
                TomlString("strings"),
                TomlString("are the same"),
                TomlString("type"),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "integers2 = [\n  1, 2, 3\n]\n\nintegers3 = [\n  1,\n  2, # this is ok\n]\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("integers2", TomlArray([TomlInt(1), TomlInt(2), TomlInt(3)])),
          ("integers3", TomlArray([TomlInt(1), TomlInt(2)])),
        ]
      )
    )
  )
// assert sortToml(
//   fromString(
//     "[[products]]\nname = \"Hammer\"\nsku = 738594937\n\n[[products]]  # empty table within the array\n\n[[products]]\nname = \"Nail\"\nsku = 284758393\n\ncolor = \"gray\"\n"
//   )
// ) ==
//   sortToml(
//     Ok(
//       TomlTable(
//         [
//           (
//             "products",
//             TomlArray(
//               [
//                 TomlTable(
//                   [("name", TomlString("Hammer")), ("sku", TomlInt(738594937))]
//                 ),
//                 TomlTable([]),
//                 TomlTable(
//                   [
//                     ("color", TomlString("gray")),
//                     ("name", TomlString("Nail")),
//                     ("sku", TomlInt(284758393)),
//                   ]
//                 ),
//               ]
//             ),
//           ),
//         ]
//       )
//     )
//   )
// assert sortToml(
//   fromString(
//     "[[fruits]]\nname = \"apple\"\n\n[fruits.physical]  # subtable\ncolor = \"red\"\nshape = \"round\"\n\n[[fruits.varieties]]  # nested array of tables\nname = \"red delicious\"\n\n[[fruits.varieties]]\nname = \"granny smith\"\n\n\n[[fruits]]\nname = \"banana\"\n\n[[fruits.varieties]]\nname = \"plantain\"\n"
//   )
// ) ==
//   sortToml(
//     Ok(
//       TomlTable(
//         [
//           (
//             "fruits",
//             TomlArray(
//               [
//                 TomlTable(
//                   [
//                     ("name", TomlString("apple")),
//                     (
//                       "physical",
//                       TomlTable(
//                         [
//                           ("color", TomlString("red")),
//                           ("shape", TomlString("round")),
//                         ]
//                       ),
//                     ),
//                     (
//                       "varieties",
//                       TomlArray(
//                         [
//                           TomlTable([("name", TomlString("red delicious"))]),
//                           TomlTable([("name", TomlString("granny smith"))]),
//                         ]
//                       ),
//                     ),
//                   ]
//                 ),
//                 TomlTable(
//                   [
//                     ("name", TomlString("banana")),
//                     (
//                       "varieties",
//                       TomlArray(
//                         [TomlTable([("name", TomlString("plantain"))])]
//                       ),
//                     ),
//                   ]
//                 ),
//               ]
//             ),
//           ),
//         ]
//       )
//     )
//   )
assert sortToml(
  fromString(
    "points = [ { x = 1, y = 2, z = 3 },\n           { x = 7, y = 8, z = 9 },\n           { x = 2, y = 4, z = 8 } ]\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "points",
            TomlArray(
              [
                TomlTable(
                  [("x", TomlInt(1)), ("y", TomlInt(2)), ("z", TomlInt(3))]
                ),
                TomlTable(
                  [("x", TomlInt(7)), ("y", TomlInt(8)), ("z", TomlInt(9))]
                ),
                TomlTable(
                  [("x", TomlInt(2)), ("y", TomlInt(4)), ("z", TomlInt(8))]
                ),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(fromString("bool1 = true\nbool2 = false\n")) ==
  sortToml(
    Ok(TomlTable([("bool1", TomlBool(true)), ("bool2", TomlBool(false))]))
  )
assert sortToml(
  fromString(
    "# This is a full-line comment\nkey = \"value\"  # This is a comment at the end of a line\nanother = \"# This is not a comment\"\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("another", TomlString("# This is not a comment")),
          ("key", TomlString("value")),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "# fractional\nflt1 = +1.0\nflt2 = 3.1415\nflt3 = -0.01\n\n# exponent\nflt4 = 5e+22\nflt5 = 1e06\nflt6 = -2E-2\n\n# both\nflt7 = 6.626e-34\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("flt1", TomlFloat(1)),
          ("flt2", TomlFloat(3.1415)),
          ("flt3", TomlFloat(-0.01)),
          ("flt4", TomlFloat(5e+22)),
          ("flt5", TomlFloat(1e+06)),
          ("flt6", TomlFloat(-0.02)),
          ("flt7", TomlFloat(6.626e-34)),
        ]
      )
    )
  )
assert sortToml(fromString("flt8 = 224_617.445_991_228\n")) ==
  sortToml(Ok(TomlTable([("flt8", TomlFloat(224617.445991228))])))
assert toString(
  sortToml(
    fromString(
      "# infinity\nsf1 = inf  # positive infinity\nsf2 = +inf # positive infinity\nsf3 = -inf # negative infinity\n\n# not a number\nsf4 = nan  # actual sNaN/qNaN encoding is implementation-specific\nsf5 = +nan # same as `nan`\nsf6 = -nan # valid, actual encoding is implementation-specific\n"
    )
  )
) ==
  toString(
    sortToml(
      Ok(
        TomlTable(
          [
            ("sf1", TomlInt(Infinity)),
            ("sf2", TomlInt(Infinity)),
            ("sf3", TomlFloat(-Infinity)),
            ("sf4", TomlFloat(NaN)),
            ("sf5", TomlFloat(NaN)),
            ("sf6", TomlFloat(NaN)),
          ]
        )
      )
    )
  )
assert sortToml(
  fromString(
    "name = { first = \"Tom\", last = \"Preston-Werner\" }\npoint = { x = 1, y = 2 }\nanimal = { type.name = \"pug\" }\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "animal",
            TomlTable([("type", TomlTable([("name", TomlString("pug"))]))]),
          ),
          (
            "name",
            TomlTable(
              [
                ("first", TomlString("Tom")),
                ("last", TomlString("Preston-Werner")),
              ]
            ),
          ),
          ("point", TomlTable([("x", TomlInt(1)), ("y", TomlInt(2))])),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "[name]\nfirst = \"Tom\"\nlast = \"Preston-Werner\"\n\n[point]\nx = 1\ny = 2\n\n[animal]\ntype.name = \"pug\"\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "animal",
            TomlTable([("type", TomlTable([("name", TomlString("pug"))]))]),
          ),
          (
            "name",
            TomlTable(
              [
                ("first", TomlString("Tom")),
                ("last", TomlString("Preston-Werner")),
              ]
            ),
          ),
          ("point", TomlTable([("x", TomlInt(1)), ("y", TomlInt(2))])),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "[product]\ntype = { name = \"Nail\" }\n# type.edible = false  # INVALID\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "product",
            TomlTable([("type", TomlTable([("name", TomlString("Nail"))]))]),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "[product]\ntype.name = \"Nail\"\n# type = { edible = false }  # INVALID\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "product",
            TomlTable([("type", TomlTable([("name", TomlString("Nail"))]))]),
          ),
        ]
      )
    )
  )
assert sortToml(fromString("int1 = +99\nint2 = 42\nint3 = 0\nint4 = -17\n")) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("int1", TomlInt(99)),
          ("int2", TomlInt(42)),
          ("int3", TomlInt(0)),
          ("int4", TomlInt(-17)),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "int5 = 1_000\nint6 = 5_349_221\nint7 = 53_49_221  # Indian number system grouping\nint8 = 1_2_3_4_5  # VALID but discouraged\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("int5", TomlInt(1000)),
          ("int6", TomlInt(5349221)),
          ("int7", TomlInt(5349221)),
          ("int8", TomlInt(12345)),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "# hexadecimal with prefix `0x`\nhex1 = 0xDEADBEEF\nhex2 = 0xdeadbeef\nhex3 = 0xdead_beef\n\n# octal with prefix `0o`\noct1 = 0o01234567\noct2 = 0o755 # useful for Unix file permissions\n\n# binary with prefix `0b`\nbin1 = 0b11010110\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("bin1", TomlInt(214)),
          ("hex1", TomlInt(3735928559)),
          ("hex2", TomlInt(3735928559)),
          ("hex3", TomlInt(3735928559)),
          ("oct1", TomlInt(342391)),
          ("oct2", TomlInt(493)),
        ]
      )
    )
  )
assert sortToml(fromString("key = \"value\"\n")) ==
  sortToml(Ok(TomlTable([("key", TomlString("value"))])))
assert sortToml(
  fromString(
    "key = \"value\"\nbare_key = \"value\"\nbare-key = \"value\"\n1234 = \"value\"\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("1234", TomlString("value")),
          ("bare-key", TomlString("value")),
          ("bare_key", TomlString("value")),
          ("key", TomlString("value")),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "\"127.0.0.1\" = \"value\"\n\"character encoding\" = \"value\"\n\"ʎǝʞ\" = \"value\"\n'key2' = \"value\"\n'quoted \"value\"' = \"value\"\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("127.0.0.1", TomlString("value")),
          ("character encoding", TomlString("value")),
          ("key2", TomlString("value")),
          ("quoted \"value\"", TomlString("value")),
          ("ʎǝʞ", TomlString("value")),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "name = \"Orange\"\nphysical.color = \"orange\"\nphysical.shape = \"round\"\nsite.\"google.com\" = true\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("name", TomlString("Orange")),
          (
            "physical",
            TomlTable(
              [("color", TomlString("orange")), ("shape", TomlString("round"))]
            ),
          ),
          ("site", TomlTable([("google.com", TomlBool(true))])),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "fruit.name = \"banana\"     # this is best practice\nfruit. color = \"yellow\"    # same as fruit.color\nfruit . flavor = \"banana\"   # same as fruit.flavor\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "fruit",
            TomlTable(
              [
                ("color", TomlString("yellow")),
                ("flavor", TomlString("banana")),
                ("name", TomlString("banana")),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "# VALID BUT DISCOURAGED\n\napple.type = \"fruit\"\norange.type = \"fruit\"\n\napple.skin = \"thin\"\norange.skin = \"thick\"\n\napple.color = \"red\"\norange.color = \"orange\"\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "apple",
            TomlTable(
              [
                ("color", TomlString("red")),
                ("skin", TomlString("thin")),
                ("type", TomlString("fruit")),
              ]
            ),
          ),
          (
            "orange",
            TomlTable(
              [
                ("color", TomlString("orange")),
                ("skin", TomlString("thick")),
                ("type", TomlString("fruit")),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "# RECOMMENDED\n\napple.type = \"fruit\"\napple.skin = \"thin\"\napple.color = \"red\"\n\norange.type = \"fruit\"\norange.skin = \"thick\"\norange.color = \"orange\"\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "apple",
            TomlTable(
              [
                ("color", TomlString("red")),
                ("skin", TomlString("thin")),
                ("type", TomlString("fruit")),
              ]
            ),
          ),
          (
            "orange",
            TomlTable(
              [
                ("color", TomlString("orange")),
                ("skin", TomlString("thick")),
                ("type", TomlString("fruit")),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(fromString("3.14159 = \"pi\"\n")) ==
  sortToml(Ok(TomlTable([("3", TomlTable([("14159", TomlString("pi"))]))])))
assert sortToml(fromString("ld1 = 1979-05-27\n")) ==
  sortToml(Ok(TomlTable([("ld1", TomlDateLocal("1979-05-27"))])))
assert sortToml(
  fromString("ldt1 = 1979-05-27T07:32:00\nldt2 = 1979-05-27T00:32:00.999999\n")
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("ldt1", TomlDateTimeLocal("1979-05-27T07:32:00")),
          ("ldt2", TomlDateTimeLocal("1979-05-27T00:32:00.999999")),
        ]
      )
    )
  )
assert sortToml(fromString("lt1 = 07:32:00\nlt2 = 00:32:00.999999\n")) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("lt1", TomlTimeLocal("07:32:00")),
          ("lt2", TomlTimeLocal("00:32:00.999999")),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "odt1 = 1979-05-27T07:32:00Z\nodt2 = 1979-05-27T00:32:00-07:00\nodt3 = 1979-05-27T00:32:00.999999-07:00\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("odt1", TomlDateTime("1979-05-27T07:32:00Z")),
          ("odt2", TomlDateTime("1979-05-27T00:32:00-07:00")),
          ("odt3", TomlDateTime("1979-05-27T00:32:00.999999-07:00")),
        ]
      )
    )
  )
assert sortToml(fromString("odt4 = 1979-05-27 07:32:00Z\n")) ==
  sortToml(Ok(TomlTable([("odt4", TomlDateTime("1979-05-27T07:32:00Z"))])))
assert sortToml(
  fromString(
    "str = \"I'm a string. \\\"You can quote me\\\". Name\\tJos\\u00E9\\nLocation\\tSF.\"\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "str",
            TomlString(
              "I'm a string. \"You can quote me\". Name\tJosé\nLocation\tSF."
            ),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString("str1 = \"\"\"\nRoses are red\nViolets are blue\"\"\"\n")
) ==
  sortToml(
    Ok(TomlTable([("str1", TomlString("Roses are red\nViolets are blue"))]))
  )
assert sortToml(
  fromString(
    "# On a Unix system, the above multi-line string will most likely be the same as:\nstr2 = \"Roses are red\\nViolets are blue\"\n\n# On a Windows system, it will most likely be equivalent to:\nstr3 = \"Roses are red\\r\\nViolets are blue\"\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("str2", TomlString("Roses are red\nViolets are blue")),
          ("str3", TomlString("Roses are red\r\nViolets are blue")),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "# The following strings are byte-for-byte equivalent:\nstr1 = \"The quick brown fox jumps over the lazy dog.\"\n\nstr2 = \"\"\"\nThe quick brown \\\n\n\n  fox jumps over \\\n    the lazy dog.\"\"\"\n\nstr3 = \"\"\"\\\n       The quick brown \\\n       fox jumps over \\\n       the lazy dog.\\\n       \"\"\"\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("str1", TomlString("The quick brown fox jumps over the lazy dog.")),
          ("str2", TomlString("The quick brown fox jumps over the lazy dog.")),
          ("str3", TomlString("The quick brown fox jumps over the lazy dog.")),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "str4 = \"\"\"Here are two quotation marks: \"\". Simple enough.\"\"\"\n# str5 = \"\"\"Here are three quotation marks: \"\"\".\"\"\"  # INVALID\nstr5 = \"\"\"Here are three quotation marks: \"\"\\\".\"\"\"\nstr6 = \"\"\"Here are fifteen quotation marks: \"\"\\\"\"\"\\\"\"\"\\\"\"\"\\\"\"\"\\\".\"\"\"\n\n# \"This,\" she said, \"is just a pointless statement.\"\nstr7 = \"\"\"\"This,\" she said, \"is just a pointless statement.\"\"\"\"\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "str4",
            TomlString("Here are two quotation marks: \"\". Simple enough."),
          ),
          ("str5", TomlString("Here are three quotation marks: \"\"\".")),
          (
            "str6",
            TomlString(
              "Here are fifteen quotation marks: \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"."
            ),
          ),
          (
            "str7",
            TomlString(
              "\"This,\" she said, \"is just a pointless statement.\""
            ),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "# What you see is what you get.\nwinpath  = 'C:\\Users\\nodejs\\templates'\nwinpath2 = '\\\\ServerX\\admin$\\system32\\'\nquoted   = 'Tom \"Dubs\" Preston-Werner'\nregex    = '<\\i\\c*\\s*>'\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("quoted", TomlString("Tom \"Dubs\" Preston-Werner")),
          ("regex", TomlString("<\\i\\c*\\s*>")),
          ("winpath", TomlString("C:\\Users\\nodejs\\templates")),
          ("winpath2", TomlString("\\\\ServerX\\admin$\\system32\\")),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "regex2 = '''I [dw]on't need \\d{2} apples'''\nlines  = '''\nThe first newline is\ntrimmed in raw strings.\n   All other whitespace\n   is preserved.\n'''\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "lines",
            TomlString(
              "The first newline is\ntrimmed in raw strings.\n   All other whitespace\n   is preserved.\n"
            ),
          ),
          ("regex2", TomlString("I [dw]on't need \\d{2} apples")),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "quot15 = '''Here are fifteen quotation marks: \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"'''\n\n# apos15 = '''Here are fifteen apostrophes: ''''''''''''''''''  # INVALID\napos15 = \"Here are fifteen apostrophes: '''''''''''''''\"\n\n# 'That,' she said, 'is still pointless.'\nstr = ''''That,' she said, 'is still pointless.''''\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "apos15",
            TomlString("Here are fifteen apostrophes: '''''''''''''''"),
          ),
          (
            "quot15",
            TomlString(
              "Here are fifteen quotation marks: \"\"\"\"\"\"\"\"\"\"\"\"\"\"\""
            ),
          ),
          ("str", TomlString("'That,' she said, 'is still pointless.'")),
        ]
      )
    )
  )
assert sortToml(fromString("[table]\n")) ==
  sortToml(Ok(TomlTable([("table", TomlTable([]))])))
assert sortToml(
  fromString(
    "[table-1]\nkey1 = \"some string\"\nkey2 = 123\n\n[table-2]\nkey1 = \"another string\"\nkey2 = 456\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "table-1",
            TomlTable(
              [("key1", TomlString("some string")), ("key2", TomlInt(123))]
            ),
          ),
          (
            "table-2",
            TomlTable(
              [("key1", TomlString("another string")), ("key2", TomlInt(456))]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(fromString("[dog.\"tater.man\"]\ntype.name = \"pug\"\n")) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "dog",
            TomlTable(
              [
                (
                  "tater.man",
                  TomlTable(
                    [("type", TomlTable([("name", TomlString("pug"))]))]
                  ),
                ),
              ]
            ),
          ),
        ]
      )
    )
  )
// assert sortToml(
//   fromString(
//     "[a.b.c]            # this is best practice\n[ d.e.f ]          # same as [d.e.f]\n[ g .  h  . i ]    # same as [g.h.i]\n[ j . \"ʞ\" . 'l' ]  # same as [j.\"ʞ\".'l']\n"
//   )
// ) ==
//   sortToml(
//     Ok(
//       TomlTable(
//         [
//           ("a", TomlTable([("b", TomlTable([("c", TomlTable([]))]))])),
//           ("d", TomlTable([("e", TomlTable([("f", TomlTable([]))]))])),
//           ("g", TomlTable([("h", TomlTable([("i", TomlTable([]))]))])),
//           ("j", TomlTable([("ʞ", TomlTable([("l", TomlTable([]))]))])),
//         ]
//       )
//     )
//   )
assert sortToml(
  fromString(
    "# [x] you\n# [x.y] don't\n# [x.y.z] need these\n[x.y.z.w] # for this to work\n\n[x] # defining a super-table afterward is ok\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "x",
            TomlTable(
              [("y", TomlTable([("z", TomlTable([("w", TomlTable([]))]))]))]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "# VALID BUT DISCOURAGED\n[fruit.apple]\n[animal]\n[fruit.orange]\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("animal", TomlTable([])),
          (
            "fruit",
            TomlTable([("apple", TomlTable([])), ("orange", TomlTable([]))]),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString("# RECOMMENDED\n[fruit.apple]\n[fruit.orange]\n[animal]\n")
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("animal", TomlTable([])),
          (
            "fruit",
            TomlTable([("apple", TomlTable([])), ("orange", TomlTable([]))]),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "# Top-level table begins.\nname = \"Fido\"\nbreed = \"pug\"\n\n# Top-level table ends.\n[owner]\nname = \"Regina Dogman\"\nmember_since = 1999-08-04\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("breed", TomlString("pug")),
          ("name", TomlString("Fido")),
          (
            "owner",
            TomlTable(
              [
                ("member_since", TomlDateLocal("1999-08-04")),
                ("name", TomlString("Regina Dogman")),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "fruit.apple.color = \"red\"\n# Defines a table named fruit\n# Defines a table named fruit.apple\n\nfruit.apple.taste.sweet = true\n# Defines a table named fruit.apple.taste\n# fruit and fruit.apple were already created\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "fruit",
            TomlTable(
              [
                (
                  "apple",
                  TomlTable(
                    [
                      ("color", TomlString("red")),
                      ("taste", TomlTable([("sweet", TomlBool(true))])),
                    ]
                  ),
                ),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "[fruit]\napple.color = \"red\"\napple.taste.sweet = true\n\n# [fruit.apple]  # INVALID\n# [fruit.apple.taste]  # INVALID\n\n[fruit.apple.texture]  # you can add sub-tables\nsmooth = true\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "fruit",
            TomlTable(
              [
                (
                  "apple",
                  TomlTable(
                    [
                      ("color", TomlString("red")),
                      ("taste", TomlTable([("sweet", TomlBool(true))])),
                      ("texture", TomlTable([("smooth", TomlBool(true))])),
                    ]
                  ),
                ),
              ]
            ),
          ),
        ]
      )
    )
  )

// key
assert sortToml(
  fromString(
    "alpha = \"a\"\n123 = \"num\"\n000111 = \"leading\"\n10e3 = \"false float\"\none1two2 = \"mixed\"\nwith-dash = \"dashed\"\nunder_score = \"___\"\n34-11 = 23\n\n[2018_10]\n001 = 1\n\n[a-a-a]\n_ = false\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("000111", TomlString("leading")),
          ("10e3", TomlString("false float")),
          ("123", TomlString("num")),
          ("2018_10", TomlTable([("001", TomlInt(1))])),
          ("34-11", TomlInt(23)),
          ("a-a-a", TomlTable([("_", TomlBool(false))])),
          ("alpha", TomlString("a")),
          ("one1two2", TomlString("mixed")),
          ("under_score", TomlString("___")),
          ("with-dash", TomlString("dashed")),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "sectioN = \"NN\"\n\n[section]\nname = \"lower\"\nNAME = \"upper\"\nName = \"capitalized\"\n\n[Section]\nname = \"different section!!\"\n\"μ\" = \"greek small letter mu\"\n\"Μ\" = \"greek capital letter MU\"\nM = \"latin letter M\"\n\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "Section",
            TomlTable(
              [
                ("M", TomlString("latin letter M")),
                ("name", TomlString("different section!!")),
                ("Μ", TomlString("greek capital letter MU")),
                ("μ", TomlString("greek small letter mu")),
              ]
            ),
          ),
          ("sectioN", TomlString("NN")),
          (
            "section",
            TomlTable(
              [
                ("NAME", TomlString("upper")),
                ("Name", TomlString("capitalized")),
                ("name", TomlString("lower")),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "''.x = \"empty.x\"\nx.\"\" = \"x.empty\"\n[a]\n\"\".'' = \"empty.empty\"\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("", TomlTable([("x", TomlString("empty.x"))])),
          ("x", TomlTable([("", TomlString("x.empty"))])),
          (
            "a",
            TomlTable([("", TomlTable([("", TomlString("empty.empty"))]))]),
          ),
        ]
      )
    )
  )
// assert sortToml(
//   fromString(
//     "# Note: this file contains literal tab characters.\n\nname.first = \"Arthur\"\n\"name\".'last' = \"Dent\"\n\nmany.dots.here.dot.dot.dot = 42\n\n# Space are ignored, and key parts can be quoted.\ncount.a       = 1\ncount . b     = 2\n\"count\".\"c\"   = 3\n\"count\" . \"d\" = 4\n'count'.'e'   = 5\n'count' . 'f' = 6\n\"count\".'g'   = 7\n\"count\" . 'h' = 8\ncount.'i'     = 9\ncount \t.\t 'j'\t   = 10\n\"count\".k     = 11\n\"count\" . l   = 12\n\n[tbl]\na.b.c = 42.666\n\n[a.few.dots]\npolka.dot = \"again?\"\npolka.dance-with = \"Dot\"\n\n[[arr]]\na.b.c=1\na.b.d=2\n\n[[arr]]\na.b.c=3\na.b.d=4\n"
//   )
// ) ==
//   sortToml(
//     Ok(
//       TomlTable(
//         [
//           (
//             "a",
//             TomlTable(
//               [
//                 (
//                   "few",
//                   TomlTable(
//                     [
//                       (
//                         "dots",
//                         TomlTable(
//                           [
//                             (
//                               "polka",
//                               TomlTable(
//                                 [
//                                   ("dance-with", TomlString("Dot")),
//                                   ("dot", TomlString("again?")),
//                                 ]
//                               ),
//                             ),
//                           ]
//                         ),
//                       ),
//                     ]
//                   ),
//                 ),
//               ]
//             ),
//           ),
//           (
//             "arr",
//             TomlArray(
//               [
//                 TomlTable(
//                   [
//                     (
//                       "a",
//                       TomlTable(
//                         [
//                           (
//                             "b",
//                             TomlTable([("c", TomlInt(1)), ("d", TomlInt(2))]),
//                           ),
//                         ]
//                       ),
//                     ),
//                   ]
//                 ),
//                 TomlTable(
//                   [
//                     (
//                       "a",
//                       TomlTable(
//                         [
//                           (
//                             "b",
//                             TomlTable([("c", TomlInt(3)), ("d", TomlInt(4))]),
//                           ),
//                         ]
//                       ),
//                     ),
//                   ]
//                 ),
//               ]
//             ),
//           ),
//           (
//             "count",
//             TomlTable(
//               [
//                 ("a", TomlInt(1)),
//                 ("b", TomlInt(2)),
//                 ("c", TomlInt(3)),
//                 ("d", TomlInt(4)),
//                 ("e", TomlInt(5)),
//                 ("f", TomlInt(6)),
//                 ("g", TomlInt(7)),
//                 ("h", TomlInt(8)),
//                 ("i", TomlInt(9)),
//                 ("j", TomlInt(10)),
//                 ("k", TomlInt(11)),
//                 ("l", TomlInt(12)),
//               ]
//             ),
//           ),
//           (
//             "many",
//             TomlTable(
//               [
//                 (
//                   "dots",
//                   TomlTable(
//                     [
//                       (
//                         "here",
//                         TomlTable(
//                           [
//                             (
//                               "dot",
//                               TomlTable(
//                                 [("dot", TomlTable([("dot", TomlInt(42))]))]
//                               ),
//                             ),
//                           ]
//                         ),
//                       ),
//                     ]
//                   ),
//                 ),
//               ]
//             ),
//           ),
//           (
//             "name",
//             TomlTable(
//               [("first", TomlString("Arthur")), ("last", TomlString("Dent"))]
//             ),
//           ),
//           (
//             "tbl",
//             TomlTable(
//               [("a", TomlTable([("b", TomlTable([("c", TomlFloat(42.666))]))]))]
//             ),
//           ),
//         ]
//       )
//     )
//   )
assert sortToml(fromString("\"\" = \"blank\"\n")) ==
  sortToml(Ok(TomlTable([("", TomlString("blank"))])))
assert sortToml(fromString("answer=42\n")) ==
  sortToml(Ok(TomlTable([("answer", TomlInt(42))])))
assert sortToml(
  fromString(
    "\"\\n\" = \"newline\"\n\"\\u00c0\" = \"latin capital letter A with grave\"\n\"\\\"\" = \"just a quote\"\n\n[\"backsp\\b\\b\"]\n\n[\"\\\"quoted\\\"\"]\nquote = true\n\n[\"a.b\".\"\\u00c0\"]\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("\n", TomlString("newline")),
          ("\"", TomlString("just a quote")),
          ("\"quoted\"", TomlTable([("quote", TomlBool(true))])),
          ("a.b", TomlTable([("À", TomlTable([]))])),
          ("backsp", TomlTable([])),
          ("À", TomlString("latin capital letter A with grave")),
        ]
      )
    )
  )
assert sortToml(fromString("1.2 = 3\n")) ==
  sortToml(Ok(TomlTable([("1", TomlTable([("2", TomlInt(3))]))])))
assert sortToml(fromString("1 = 1\n")) ==
  sortToml(Ok(TomlTable([("1", TomlInt(1))])))
assert sortToml(
  fromString(
    "plain = 1\n\"with.dot\" = 2\n\n[plain_table]\nplain = 3\n\"with.dot\" = 4\n\n[table.withdot]\nplain = 5\n\"key.with.dots\" = 6\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("plain", TomlInt(1)),
          (
            "plain_table",
            TomlTable([("plain", TomlInt(3)), ("with.dot", TomlInt(4))]),
          ),
          (
            "table",
            TomlTable(
              [
                (
                  "withdot",
                  TomlTable(
                    [("key.with.dots", TomlInt(6)), ("plain", TomlInt(5))]
                  ),
                ),
              ]
            ),
          ),
          ("with.dot", TomlInt(2)),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "\n\"\\u0000\" = \"null\"\n'\\u0000' = \"different key\"\n\"\\u0008 \\u000c \\U00000041 \\u007f \\u0080 \\u00ff \\ud7ff \\ue000 \\uffff \\U00010000 \\U0010ffff\" = \"escaped key\"\n\n\"~  ÿ ퟿  ￿ 𐀀 􏿿\" = \"basic key\"\n'l ~  ÿ ퟿  ￿ 𐀀 􏿿' = \"literal key\"\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (" ", TomlString("null")),
          ("\\u0000", TomlString("different key")),
          ("  A   ÿ ퟿  ￿ 𐀀 􏿿", TomlString("escaped key")),
          ("~  ÿ ퟿  ￿ 𐀀 􏿿", TomlString("basic key")),
          ("l ~  ÿ ퟿  ￿ 𐀀 􏿿", TomlString("literal key")),
        ]
      )
    )
  )
// assert sortToml(
//   fromString(
//     "# Keep whitespace inside quotes keys at all positions.\n\"a b\"   = 1\n\" c d \" = 2\n\n[ \" tbl \" ]\n\"\\ttab\\ttab\\t\" = \"tab\"\n"
//   )
// ) ==
//   sortToml(
//     Ok(
//       TomlTable(
//         [
//           (" c d ", TomlInt(2)),
//           (" tbl ", TomlTable([("\ttab\ttab\t", TomlString("tab"))])),
//           ("a b", TomlInt(1)),
//         ]
//       )
//     )
//   )
assert sortToml(
  fromString("\"=~!@$^&*()_+-`1234567890[]|/?><.,;:'=\" = 1\n")
) ==
  sortToml(
    Ok(TomlTable([("=~!@$^&*()_+-`1234567890[]|/?><.,;:'=", TomlInt(1))]))
  )
assert sortToml(
  fromString(
    "false = false\ntrue = 1\ninf = 100000000\nnan = \"ceci n'est pas un nombre\"\n\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("false", TomlBool(false)),
          ("inf", TomlInt(100000000)),
          ("nan", TomlString("ceci n'est pas un nombre")),
          ("true", TomlInt(1)),
        ]
      )
    )
  )
// assert sortToml(
//   fromString(
//     "# TOML 1.1 supports Unicode for bare keys.\n\n€ = 'Euro'\n😂 = \"rofl\"\na‍b = \"zwj\"\nÅÅ = \"U+00C5 U+0041 U+030A\"\n\n[中文]\n中文 = {中文 = \"Chinese language\"}\n\n[[tiếng-Việt]]\ntiəŋ˧˦.viət̚˧˨ʔ = \"north\"\n\n[[tiếng-Việt]]\ntiəŋ˦˧˥.viək̚˨˩ʔ = \"central\"\n"
//   )
// ) ==
//   sortToml(
//     Ok(
//       TomlTable(
//         [
//           ("a‍b", TomlString("zwj")),
//           (
//             "tiếng-Việt",
//             TomlArray(
//               [
//                 TomlTable(
//                   [
//                     (
//                       "tiəŋ˧˦",
//                       TomlTable([("viət̚˧˨ʔ", TomlString("north"))]),
//                     ),
//                   ]
//                 ),
//                 TomlTable(
//                   [
//                     (
//                       "tiəŋ˦˧˥",
//                       TomlTable([("viək̚˨˩ʔ", TomlString("central"))]),
//                     ),
//                   ]
//                 ),
//               ]
//             ),
//           ),
//           ("ÅÅ", TomlString("U+00C5 U+0041 U+030A")),
//           ("€", TomlString("Euro")),
//           (
//             "中文",
//             TomlTable(
//               [
//                 (
//                   "中文",
//                   TomlTable([("中文", TomlString("Chinese language"))]),
//                 ),
//               ]
//             ),
//           ),
//           ("😂", TomlString("rofl")),
//         ]
//       )
//     )
//   )

// integer
assert sortToml(
  fromString("answer = 42\nposanswer = +42\nneganswer = -42\nzero = 0\n")
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("answer", TomlInt(42)),
          ("neganswer", TomlInt(-42)),
          ("posanswer", TomlInt(42)),
          ("zero", TomlInt(0)),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "bin1 = 0b11010110\nbin2 = 0b1_0_1\n\noct1 = 0o01234567\noct2 = 0o755\noct3 = 0o7_6_5\n\nhex1 = 0xDEADBEEF\nhex2 = 0xdeadbeef\nhex3 = 0xdead_beef\nhex4 = 0x00987\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("bin1", TomlInt(214)),
          ("bin2", TomlInt(5)),
          ("hex1", TomlInt(3735928559)),
          ("hex2", TomlInt(3735928559)),
          ("hex3", TomlInt(3735928559)),
          ("hex4", TomlInt(2439)),
          ("oct1", TomlInt(342391)),
          ("oct2", TomlInt(493)),
          ("oct3", TomlInt(501)),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "int64-max = 9223372036854775807\nint64-max-neg = -9223372036854775808\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("int64-max", TomlInt(9223372036854775807)),
          ("int64-max-neg", TomlInt(-9223372036854775808)),
        ]
      )
    )
  )
assert sortToml(fromString("kilo = 1_000\nx = 1_1_1_1\n")) ==
  sortToml(Ok(TomlTable([("kilo", TomlInt(1000)), ("x", TomlInt(1111))])))
assert sortToml(
  fromString(
    "d1 = 0\nd2 = +0\nd3 = -0\n\nh1 = 0x0\nh2 = 0x00\nh3 = 0x00000\n\no1 = 0o0\na2 = 0o00\na3 = 0o00000\n\nb1 = 0b0\nb2 = 0b00\nb3 = 0b00000\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("a2", TomlInt(0)),
          ("a3", TomlInt(0)),
          ("b1", TomlInt(0)),
          ("b2", TomlInt(0)),
          ("b3", TomlInt(0)),
          ("d1", TomlInt(0)),
          ("d2", TomlInt(0)),
          ("d3", TomlInt(0)),
          ("h1", TomlInt(0)),
          ("h2", TomlInt(0)),
          ("h3", TomlInt(0)),
          ("o1", TomlInt(0)),
        ]
      )
    )
  )

// inline-table
assert sortToml(
  fromString(
    "people = [{first_name = \"Bruce\", last_name = \"Springsteen\"},\n          {first_name = \"Eric\", last_name = \"Clapton\"},\n          {first_name = \"Bob\", last_name = \"Seger\"}]\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "people",
            TomlArray(
              [
                TomlTable(
                  [
                    ("first_name", TomlString("Bruce")),
                    ("last_name", TomlString("Springsteen")),
                  ]
                ),
                TomlTable(
                  [
                    ("first_name", TomlString("Eric")),
                    ("last_name", TomlString("Clapton")),
                  ]
                ),
                TomlTable(
                  [
                    ("first_name", TomlString("Bob")),
                    ("last_name", TomlString("Seger")),
                  ]
                ),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(fromString("a = {a = true, b = false}\n")) ==
  sortToml(
    Ok(
      TomlTable(
        [("a", TomlTable([("a", TomlBool(true)), ("b", TomlBool(false))]))]
      )
    )
  )
assert sortToml(
  fromString(
    "empty1 = {}\nempty2 = { }\nempty_in_array = [ { not_empty = 1 }, {} ]\nempty_in_array2 = [{},{not_empty=1}]\nmany_empty = [{},{},{}]\nnested_empty = {\"empty\"={}}\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("empty1", TomlTable([])),
          ("empty2", TomlTable([])),
          (
            "empty_in_array",
            TomlArray([TomlTable([("not_empty", TomlInt(1))]), TomlTable([])]),
          ),
          (
            "empty_in_array2",
            TomlArray([TomlTable([]), TomlTable([("not_empty", TomlInt(1))])]),
          ),
          (
            "many_empty",
            TomlArray([TomlTable([]), TomlTable([]), TomlTable([])]),
          ),
          ("nested_empty", TomlTable([("empty", TomlTable([]))])),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "black = { python=\">3.6\", version=\">=18.9b0\", allow_prereleases=true }\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "black",
            TomlTable(
              [
                ("allow_prereleases", TomlBool(true)),
                ("python", TomlString(">3.6")),
                ("version", TomlString(">=18.9b0")),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "name = { first = \"Tom\", last = \"Preston-Werner\" }\npoint = { x = 1, y = 2 }\nsimple = { a = 1 }\nstr-key = { \"a\" = 1 }\ntable-array = [{ \"a\" = 1 }, { \"b\" = 2 }]\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "name",
            TomlTable(
              [
                ("first", TomlString("Tom")),
                ("last", TomlString("Preston-Werner")),
              ]
            ),
          ),
          ("point", TomlTable([("x", TomlInt(1)), ("y", TomlInt(2))])),
          ("simple", TomlTable([("a", TomlInt(1))])),
          ("str-key", TomlTable([("a", TomlInt(1))])),
          (
            "table-array",
            TomlArray(
              [TomlTable([("a", TomlInt(1))]), TomlTable([("b", TomlInt(2))])]
            ),
          ),
        ]
      )
    )
  )
// assert sortToml(
//   fromString(
//     "inline = {a.b = 42}\n\nmany.dots.here.dot.dot.dot = {a.b.c = 1, a.b.d = 2}\n\na = {   a.b  =  1   }\nb = {   \"a\".\"b\"  =  1   }\nc = {   a   .   b  =  1   }\nd = {   'a'   .   \"b\"  =  1   }\ne = {a.b=1}\n\n[tbl]\na.b.c = {d.e=1}\n\n[tbl.x]\na.b.c = {d.e=1}\n\n[[arr]]\nt = {a.b=1}\nT = {a.b=1}\n\n[[arr]]\nt = {a.b=2}\nT = {a.b=2}\n"
//   )
// ) ==
//   sortToml(
//     Ok(
//       TomlTable(
//         [
//           ("a", TomlTable([("a", TomlTable([("b", TomlInt(1))]))])),
//           (
//             "arr",
//             TomlArray(
//               [
//                 TomlTable(
//                   [
//                     ("T", TomlTable([("a", TomlTable([("b", TomlInt(1))]))])),
//                     ("t", TomlTable([("a", TomlTable([("b", TomlInt(1))]))])),
//                   ]
//                 ),
//                 TomlTable(
//                   [
//                     ("T", TomlTable([("a", TomlTable([("b", TomlInt(2))]))])),
//                     ("t", TomlTable([("a", TomlTable([("b", TomlInt(2))]))])),
//                   ]
//                 ),
//               ]
//             ),
//           ),
//           ("b", TomlTable([("a", TomlTable([("b", TomlInt(1))]))])),
//           ("c", TomlTable([("a", TomlTable([("b", TomlInt(1))]))])),
//           ("d", TomlTable([("a", TomlTable([("b", TomlInt(1))]))])),
//           ("e", TomlTable([("a", TomlTable([("b", TomlInt(1))]))])),
//           ("inline", TomlTable([("a", TomlTable([("b", TomlInt(42))]))])),
//           (
//             "many",
//             TomlTable(
//               [
//                 (
//                   "dots",
//                   TomlTable(
//                     [
//                       (
//                         "here",
//                         TomlTable(
//                           [
//                             (
//                               "dot",
//                               TomlTable(
//                                 [
//                                   (
//                                     "dot",
//                                     TomlTable(
//                                       [
//                                         (
//                                           "dot",
//                                           TomlTable(
//                                             [
//                                               (
//                                                 "a",
//                                                 TomlTable(
//                                                   [
//                                                     (
//                                                       "b",
//                                                       TomlTable(
//                                                         [
//                                                           ("c", TomlInt(1)),
//                                                           ("d", TomlInt(2)),
//                                                         ]
//                                                       ),
//                                                     ),
//                                                   ]
//                                                 ),
//                                               ),
//                                             ]
//                                           ),
//                                         ),
//                                       ]
//                                     ),
//                                   ),
//                                 ]
//                               ),
//                             ),
//                           ]
//                         ),
//                       ),
//                     ]
//                   ),
//                 ),
//               ]
//             ),
//           ),
//           (
//             "tbl",
//             TomlTable(
//               [
//                 (
//                   "a",
//                   TomlTable(
//                     [
//                       (
//                         "b",
//                         TomlTable(
//                           [
//                             (
//                               "c",
//                               TomlTable(
//                                 [("d", TomlTable([("e", TomlInt(1))]))]
//                               ),
//                             ),
//                           ]
//                         ),
//                       ),
//                     ]
//                   ),
//                 ),
//                 (
//                   "x",
//                   TomlTable(
//                     [
//                       (
//                         "a",
//                         TomlTable(
//                           [
//                             (
//                               "b",
//                               TomlTable(
//                                 [
//                                   (
//                                     "c",
//                                     TomlTable(
//                                       [("d", TomlTable([("e", TomlInt(1))]))]
//                                     ),
//                                   ),
//                                 ]
//                               ),
//                             ),
//                           ]
//                         ),
//                       ),
//                     ]
//                   ),
//                 ),
//               ]
//             ),
//           ),
//         ]
//       )
//     )
//   )
assert sortToml(
  fromString(
    "tbl_multiline = { a = 1, b = \"\"\"\nmultiline\n\"\"\", c = \"\"\"and yet\nanother line\"\"\", d = 4 }\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "tbl_multiline",
            TomlTable(
              [
                ("a", TomlInt(1)),
                ("b", TomlString("multiline\n")),
                ("c", TomlString("and yet\nanother line")),
                ("d", TomlInt(4)),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "tbl_tbl_empty = { tbl_0 = {} }\ntbl_tbl_val   = { tbl_1 = { one = 1 } }\ntbl_arr_tbl   = { arr_tbl = [ { one = 1 } ] }\narr_tbl_tbl   = [ { tbl = { one = 1 } } ]\n\n# Array-of-array-of-table is interesting because it can only\n# be represented in inline form.\narr_arr_tbl_empty = [ [ {} ] ]\narr_arr_tbl_val = [ [ { one = 1 } ] ]\narr_arr_tbls  = [ [ { one = 1 }, { two = 2 } ] ]\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("arr_arr_tbl_empty", TomlArray([TomlArray([TomlTable([])])])),
          (
            "arr_arr_tbl_val",
            TomlArray([TomlArray([TomlTable([("one", TomlInt(1))])])]),
          ),
          (
            "arr_arr_tbls",
            TomlArray(
              [
                TomlArray(
                  [
                    TomlTable([("one", TomlInt(1))]),
                    TomlTable([("two", TomlInt(2))]),
                  ]
                ),
              ]
            ),
          ),
          (
            "arr_tbl_tbl",
            TomlArray([TomlTable([("tbl", TomlTable([("one", TomlInt(1))]))])]),
          ),
          (
            "tbl_arr_tbl",
            TomlTable(
              [("arr_tbl", TomlArray([TomlTable([("one", TomlInt(1))])]))]
            ),
          ),
          ("tbl_tbl_empty", TomlTable([("tbl_0", TomlTable([]))])),
          (
            "tbl_tbl_val",
            TomlTable([("tbl_1", TomlTable([("one", TomlInt(1))]))]),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "# TOML 1.1 supports newlines in inline tables and trailing commas.\n\ntrailing-comma-1 = {\n\tc = 1,\n}\ntrailing-comma-2 = { c = 1, }\n\ntbl-1 = {\n\thello = \"world\",\n\t1     = 2,\n\tarr   = [1,\n\t         2,\n\t         3,\n\t        ],\n\ttbl = {\n\t\t k = 1,\n\t}\n}\n\ntbl-2 = {\n\tk = \"\"\"\n\tHello\n\t\"\"\"\n}\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "tbl-1",
            TomlTable(
              [
                ("1", TomlInt(2)),
                ("arr", TomlArray([TomlInt(1), TomlInt(2), TomlInt(3)])),
                ("hello", TomlString("world")),
                ("tbl", TomlTable([("k", TomlInt(1))])),
              ]
            ),
          ),
          ("tbl-2", TomlTable([("k", TomlString("\tHello\n\t"))])),
          ("trailing-comma-1", TomlTable([("c", TomlInt(1))])),
          ("trailing-comma-2", TomlTable([("c", TomlInt(1))])),
        ]
      )
    )
  )

// float
assert sortToml(
  fromString(
    "lower = 3e2\nupper = 3E2\nneg = 3e-2\npos = 3E+2\nzero = 3e0\npointlower = 3.1e2\npointupper = 3.1E2\nminustenth = -1E-1\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("lower", TomlFloat(300.0)),
          ("minustenth", TomlFloat(-0.1)),
          ("neg", TomlFloat(0.03)),
          ("pointlower", TomlFloat(310.0)),
          ("pointupper", TomlFloat(310.0)),
          ("pos", TomlFloat(300.0)),
          ("upper", TomlFloat(300.0)),
          ("zero", TomlFloat(3.0)),
        ]
      )
    )
  )
assert sortToml(
  fromString("pi = 3.14\npospi = +3.14\nnegpi = -3.14\nzero-intpart = 0.123\n")
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("negpi", TomlFloat(-3.14)),
          ("pi", TomlFloat(3.14)),
          ("pospi", TomlFloat(3.14)),
          ("zero-intpart", TomlFloat(0.123)),
        ]
      )
    )
  )
assert toString(
  sortToml(
    fromString(
      "# We don't encode +nan and -nan back with the signs; many languages don't\n# support a sign on NaN (it doesn't really make much sense).\nnan = nan\nnan_neg = -nan\nnan_plus = +nan\ninfinity = inf\ninfinity_neg = -inf\ninfinity_plus = +inf\n"
    )
  )
) ==
  toString(
    sortToml(
      Ok(
        TomlTable(
          [
            ("infinity", TomlInt(Infinity)),
            ("infinity_neg", TomlFloat(-Infinity)),
            ("infinity_plus", TomlInt(Infinity)),
            ("nan", TomlFloat(NaN)),
            ("nan_neg", TomlFloat(NaN)),
            ("nan_plus", TomlFloat(NaN)),
          ]
        )
      )
    )
  )
assert sortToml(
  fromString("longpi = 3.141592653589793\nneglongpi = -3.141592653589793\n")
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("longpi", TomlFloat(3.141592653589793)),
          ("neglongpi", TomlFloat(-3.141592653589793)),
        ]
      )
    )
  )
assert sortToml(
  fromString("before = 3_141.5927\nafter = 3141.592_7\nexponent = 3e1_4\n")
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("after", TomlFloat(3141.5927)),
          ("before", TomlFloat(3141.5927)),
          ("exponent", TomlFloat(3.0e14)),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "zero = 0.0\nsigned-pos = +0.0\nsigned-neg = -0.0\nexponent = 0e0\nexponent-two-0 = 0e00\nexponent-signed-pos = +0e0\nexponent-signed-neg = -0e0\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("zero", TomlFloat(0)),
          ("signed-pos", TomlFloat(0)),
          ("signed-neg", TomlFloat(0)),
          ("exponent", TomlFloat(0)),
          ("exponent-two-0", TomlFloat(0)),
          ("exponent-signed-pos", TomlFloat(0)),
          ("exponent-signed-neg", TomlFloat(0)),
        ]
      )
    )
  )

// datetime
assert sortToml(
  fromString("space = 1987-07-05 17:45:00Z\nlower = 1987-07-05t17:45:00z\n")
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("lower", TomlDateTime("1987-07-05T17:45:00Z")),
          ("space", TomlDateTime("1987-07-05T17:45:00Z")),
        ]
      )
    )
  )
assert sortToml(fromString("bestdayever = 1987-07-05\n")) ==
  sortToml(Ok(TomlTable([("bestdayever", TomlDateLocal("1987-07-05"))])))
assert sortToml(
  fromString("besttimeever = 17:45:00\nmilliseconds = 10:32:00.555\n")
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("besttimeever", TomlTimeLocal("17:45:00")),
          ("milliseconds", TomlTimeLocal("10:32:00.555")),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "local = 1987-07-05T17:45:00\nmilli = 1977-12-21T10:32:00.555\nspace = 1987-07-05 17:45:00\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("local", TomlDateTimeLocal("1987-07-05T17:45:00")),
          ("milli", TomlDateTimeLocal("1977-12-21T10:32:00.555")),
          ("space", TomlDateTimeLocal("1987-07-05T17:45:00")),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "utc1  = 1987-07-05T17:45:56.1234Z\nutc2  = 1987-07-05T17:45:56.6Z\nwita1 = 1987-07-05T17:45:56.1234+08:00\nwita2 = 1987-07-05T17:45:56.6+08:00\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("utc1", TomlDateTime("1987-07-05T17:45:56.1234Z")),
          ("utc2", TomlDateTime("1987-07-05T17:45:56.6Z")),
          ("wita1", TomlDateTime("1987-07-05T17:45:56.1234+08:00")),
          ("wita2", TomlDateTime("1987-07-05T17:45:56.6+08:00")),
        ]
      )
    )
  )
// assert sortToml(
//   fromString(
//     "# Seconds are optional in date-time and time.\nwithout-seconds-1 = 13:37\nwithout-seconds-2 = 1979-05-27 07:32Z\nwithout-seconds-3 = 1979-05-27 07:32-07:00\nwithout-seconds-4 = 1979-05-27T07:32\n"
//   )
// ) ==
//   sortToml(
//     Ok(
//       TomlTable(
//         [
//           ("without-seconds-1", TomlTimeLocal("13:37:00")),
//           ("without-seconds-2", TomlDateTime("1979-05-27T07:32:00Z")),
//           ("without-seconds-3", TomlDateTime("1979-05-27T07:32:00-07:00")),
//           ("without-seconds-4", TomlDateTime("1979-05-27T07:32:00")),
//         ]
//       )
//     )
//   )
assert sortToml(
  fromString(
    "utc  = 1987-07-05T17:45:56Z\npdt  = 1987-07-05T17:45:56-05:00\nnzst = 1987-07-05T17:45:56+12:00\nnzdt = 1987-07-05T17:45:56+13:00  # DST\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("nzdt", TomlDateTime("1987-07-05T17:45:56+13:00")),
          ("nzst", TomlDateTime("1987-07-05T17:45:56+12:00")),
          ("pdt", TomlDateTime("1987-07-05T17:45:56-05:00")),
          ("utc", TomlDateTime("1987-07-05T17:45:56Z")),
        ]
      )
    )
  )

// comment
assert sortToml(
  fromString(
    "# This is a full-line comment\nkey = \"value\" # This is a comment at the end of a line\n"
  )
) ==
  sortToml(Ok(TomlTable([("key", TomlString("value"))])))
assert sortToml(
  fromString(
    "# This is a full-line comment\nkey = \"value\" # This is a comment at the end of a line\n"
  )
) ==
  sortToml(Ok(TomlTable([("key", TomlString("value"))])))
assert sortToml(
  fromString(
    "# Top comment.\n  # Top comment.\n# Top comment.\n\n# [no-extraneous-groups-please]\n\n[group] # Comment\nanswer = 42 # Comment\n# no-extraneous-keys-please = 999\n# Inbetween comment.\nmore = [ # Comment\n  # What about multiple # comments?\n  # Can you handle it?\n  #\n          # Evil.\n# Evil.\n  42, 42, # Comments within arrays are fun.\n  # What about multiple # comments?\n  # Can you handle it?\n  #\n          # Evil.\n# Evil.\n# ] Did I fool you?\n] # Hopefully not.\n\n# Make sure the space between the datetime and \"#\" isn't lexed.\ndt = 1979-05-27T07:32:12-07:00  # c\nd = 1979-05-27 # Comment\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "group",
            TomlTable(
              [
                ("answer", TomlInt(42)),
                ("dt", TomlDateTime("1979-05-27T07:32:12-07:00")),
                ("d", TomlDateLocal("1979-05-27")),
                ("more", TomlArray([TomlInt(42), TomlInt(42)])),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(fromString("# single comment without any eol characters")) ==
  sortToml(Ok(TomlTable([])))
assert sortToml(fromString("# ~  ÿ ퟿  ￿ 𐀀 􏿿\n")) ==
  sortToml(Ok(TomlTable([])))
assert sortToml(
  fromString(
    "[section]#attached comment\n#[notsection]\none = \"11\"#cmt\ntwo = \"22#\"\nthree = '#'\n\nfour = \"\"\"# no comment\n# nor this\n#also not comment\"\"\"#is_comment\n\nfive = 5.5#66\nsix = 6#7\n8 = \"eight\"\n#nine = 99\nten = 10e2#1\neleven = 1.11e1#23\n\n[\"hash#tag\"]\n\"#!\" = \"hash bang\"\narr3 = [ \"#\", '#', \"\"\"###\"\"\" ]\narr4 = [ 1,# 9, 9,\n2#,9\n,#9\n3#]\n,4]\narr5 = [[[[#[\"#\"],\n[\"#\"]]]]#]\n]\ntbl1 = { \"#\" = '}#'}#}}\n\n\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "hash#tag",
            TomlTable(
              [
                ("#!", TomlString("hash bang")),
                (
                  "arr3",
                  TomlArray(
                    [TomlString("#"), TomlString("#"), TomlString("###")]
                  ),
                ),
                (
                  "arr4",
                  TomlArray([TomlInt(1), TomlInt(2), TomlInt(3), TomlInt(4)]),
                ),
                (
                  "arr5",
                  TomlArray(
                    [
                      TomlArray(
                        [TomlArray([TomlArray([TomlArray([TomlString("#")])])])]
                      ),
                    ]
                  ),
                ),
                ("tbl1", TomlTable([("#", TomlString("}#"))])),
              ]
            ),
          ),
          (
            "section",
            TomlTable(
              [
                ("8", TomlString("eight")),
                ("eleven", TomlFloat(11.1)),
                ("five", TomlFloat(5.5)),
                (
                  "four",
                  TomlString("# no comment\n# nor this\n#also not comment"),
                ),
                ("one", TomlString("11")),
                ("six", TomlInt(6)),
                ("ten", TomlFloat(1000.0)),
                ("three", TomlString("#")),
                ("two", TomlString("22#")),
              ]
            ),
          ),
        ]
      )
    )
  )

// bool
assert sortToml(fromString("t = true\nf = false\n")) ==
  sortToml(Ok(TomlTable([("f", TomlBool(false)), ("t", TomlBool(true))])))

// array
assert sortToml(
  fromString(
    "ints = [1, 2, 3, ]\nfloats = [1.1, 2.1, 3.1]\nstrings = [\"a\", \"b\", \"c\"]\ndates = [\n  1987-07-05T17:45:00Z,\n  1979-05-27T07:32:00Z,\n  2006-06-01T11:00:00Z,\n]\ncomments = [\n         1,\n         2, #this is ok\n]\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          ("comments", TomlArray([TomlInt(1), TomlInt(2)])),
          (
            "dates",
            TomlArray(
              [
                TomlDateTime("1987-07-05T17:45:00Z"),
                TomlDateTime("1979-05-27T07:32:00Z"),
                TomlDateTime("2006-06-01T11:00:00Z"),
              ]
            ),
          ),
          (
            "floats",
            TomlArray([TomlFloat(1.1), TomlFloat(2.1), TomlFloat(3.1)]),
          ),
          ("ints", TomlArray([TomlInt(1), TomlInt(2), TomlInt(3)])),
          (
            "strings",
            TomlArray([TomlString("a"), TomlString("b"), TomlString("c")]),
          ),
        ]
      )
    )
  )
assert sortToml(fromString("a = [true, false]\n")) ==
  sortToml(Ok(TomlTable([("a", TomlArray([TomlBool(true), TomlBool(false)]))])))
assert sortToml(fromString("thevoid = [[[[[]]]]]\n")) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "thevoid",
            TomlArray([TomlArray([TomlArray([TomlArray([TomlArray([])])])])]),
          ),
        ]
      )
    )
  )
assert sortToml(fromString("mixed = [[1, 2], [\"a\", \"b\"], [1.1, 2.1]]\n")) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "mixed",
            TomlArray(
              [
                TomlArray([TomlInt(1), TomlInt(2)]),
                TomlArray([TomlString("a"), TomlString("b")]),
                TomlArray([TomlFloat(1.1), TomlFloat(2.1)]),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString("arrays-and-ints =  [1, [\"Arrays are not integers.\"]]\n")
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "arrays-and-ints",
            TomlArray(
              [TomlInt(1), TomlArray([TomlString("Arrays are not integers.")])]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(fromString("ints-and-floats = [1, 1.1]\n")) ==
  sortToml(
    Ok(
      TomlTable([("ints-and-floats", TomlArray([TomlInt(1), TomlFloat(1.1)]))])
    )
  )
assert sortToml(fromString("strings-and-ints = [\"hi\", 42]\n")) ==
  sortToml(
    Ok(
      TomlTable(
        [("strings-and-ints", TomlArray([TomlString("hi"), TomlInt(42)]))]
      )
    )
  )
assert sortToml(
  fromString(
    "contributors = [\n  \"Foo Bar <foo@example.com>\",\n  { name = \"Baz Qux\", email = \"bazqux@example.com\", url = \"https://example.com/bazqux\" }\n]\n\n# Start with a table as the first element. This tests a case that some libraries\n# might have where they will check if the first entry is a table/map/hash/assoc\n# array and then encode it as a table array. This was a reasonable thing to do\n# before TOML 1.0 since arrays could only contain one type, but now it's no\n# longer.\nmixed = [{k=\"a\"}, \"b\", 1]\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "contributors",
            TomlArray(
              [
                TomlString("Foo Bar <foo@example.com>"),
                TomlTable(
                  [
                    ("email", TomlString("bazqux@example.com")),
                    ("name", TomlString("Baz Qux")),
                    ("url", TomlString("https://example.com/bazqux")),
                  ]
                ),
              ]
            ),
          ),
          (
            "mixed",
            TomlArray(
              [TomlTable([("k", TomlString("a"))]), TomlString("b"), TomlInt(1)]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString("nest = [\n\t[\n\t\t[\"a\"],\n\t\t[1, 2, [3]]\n\t]\n]\n")
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "nest",
            TomlArray(
              [
                TomlArray(
                  [
                    TomlArray([TomlString("a")]),
                    TomlArray(
                      [TomlInt(1), TomlInt(2), TomlArray([TomlInt(3)])]
                    ),
                  ]
                ),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(fromString("a = [ { b = {} } ]\n")) ==
  sortToml(
    Ok(TomlTable([("a", TomlArray([TomlTable([("b", TomlTable([]))])]))]))
  )
assert sortToml(fromString("nest = [[\"a\"], [\"b\"]]\n")) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "nest",
            TomlArray(
              [TomlArray([TomlString("a")]), TomlArray([TomlString("b")])]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(fromString("ints = [1,2,3]\n")) ==
  sortToml(
    Ok(TomlTable([("ints", TomlArray([TomlInt(1), TomlInt(2), TomlInt(3)]))]))
  )
assert sortToml(fromString("title = [ \" \\\", \",]\n")) ==
  sortToml(Ok(TomlTable([("title", TomlArray([TomlString(" \", ")]))])))
assert sortToml(
  fromString(
    "title = [\n\"Client: \\\"XXXX\\\", Job: XXXX\",\n\"Code: XXXX\"\n]\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "title",
            TomlArray(
              [
                TomlString("Client: \"XXXX\", Job: XXXX"),
                TomlString("Code: XXXX"),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "title = [\n\"\"\"Client: XXXX,\nJob: XXXX\"\"\",\n\"Code: XXXX\"\n]\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "title",
            TomlArray(
              [TomlString("Client: XXXX,\nJob: XXXX"), TomlString("Code: XXXX")]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString("title = [\n\"Client: XXXX, Job: XXXX\",\n\"Code: XXXX\"\n]\n")
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "title",
            TomlArray(
              [TomlString("Client: XXXX, Job: XXXX"), TomlString("Code: XXXX")]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(
  fromString(
    "string_array = [ \"all\", 'strings', \"\"\"are the same\"\"\", '''type''']\n"
  )
) ==
  sortToml(
    Ok(
      TomlTable(
        [
          (
            "string_array",
            TomlArray(
              [
                TomlString("all"),
                TomlString("strings"),
                TomlString("are the same"),
                TomlString("type"),
              ]
            ),
          ),
        ]
      )
    )
  )
assert sortToml(fromString("foo = [ { bar=\"\\\"{{baz}}\\\"\"} ]\n")) ==
  sortToml(
    Ok(
      TomlTable(
        [("foo", TomlArray([TomlTable([("bar", TomlString("\"{{baz}}\""))])]))]
      )
    )
  )
