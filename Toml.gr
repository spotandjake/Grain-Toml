module Toml
include "string"
include "array"
include "list"
include "char"
include "number"
include "./src/lexer"
from Lexer use {
  type Token
}
// Lexer
provide enum TomlValue {
  TomlString(String),
  TomlInteger(Number),
  TomlFloat(Number),
  TomlBoolean(Bool),
  TomlDateTime(String, String),
  TomlDate(String),
  TomlTime(String),
  TomlTable(List<(String, TomlValue)>),
  TomlArray(List<TomlValue>),
}
let isValidKeyTable = (name) => {
  Array.every((char) => {
    let charCode = Char.code(char)
    if (charCode >= Char.code('A') && charCode <= Char.code('Z')) {
      true
    } else if (charCode >= Char.code('a') && charCode <= Char.code('z')) {
      true
    } else if (charCode >= Char.code('0') && charCode <= Char.code('9')) {
      true
    } else if (char == '-' || char == '_') {
      true
    } else {
      false
    }
  }, String.explode(String.trim(name)))
}
let parseKey = (key) => {
  // TODO: Handle Validation
  let key = Array.toList(String.explode(String.trim(key)))
  let mut closeString = ' '
  let mut keyPath = []
  let mut currentKey = ""
  List.forEach((char) => {
    // Handle String
    if (char == '\'' && closeString != '"') {
      if (closeString == '\'') closeString = ' '
      else if (closeString == ' ') closeString = '\''
      return
    } else if (char == '"' && closeString != '\'') {
      if (closeString == '"') closeString = ' '
      else if (closeString == ' ') closeString = '"'
      return
    }
    // Handle Writing Key
    if (char == '.' && closeString == ' ') {
      keyPath = [ currentKey, ...keyPath ]
      currentKey = ""
    } else currentKey = currentKey ++ Char.toString(char)
    return
  }, key)
  keyPath = [ currentKey, ...keyPath ]
  List.reverse(keyPath)
}
let rec writeTable = (rootTable, keyPath, value) => {
  // TODO: Validate This
  match (keyPath) {
    [ pathItem ] => match (rootTable) {
      TomlTable(tableContents) => {
        // Write Value
        TomlTable([
          (pathItem, value),
          ...tableContents
        ])
      },
      _ => fail "Invalid Toml Object"
    },
    [ pathItem, ...rest ] => match (rootTable) {
      TomlTable(tableContents) => {
        // Search Table
        let hasSubTable = List.some(((keyName, _)) => keyName == pathItem, tableContents)
        match (hasSubTable) {
          true => {
            TomlTable(List.map(((keyName, keyValue)) => {
              if (keyName == pathItem)
                (keyName, writeTable(keyValue, rest, value))
              else (keyName, keyValue)
            }, tableContents))
          },
          false => TomlTable([(pathItem, writeTable(TomlTable([]), rest, value)), ...tableContents])
        }
      },
      _ => fail "Invalid Toml Object"
    },
    [] => fail "Empty KeyPath"
  }
}
// TODO: Implement isNumber, isFloat
let isFloat = (str) => false
let isNumber = (str) => false
// Parsers
let rec parseValue = (buffer) => {
  match (buffer) {
    // Objects
    // Inline-Table
    [ Cbo, ...rest ] => {
      let mut buffer = rest
      // Parse Values
      let mut canDoAnother = true
      let mut rootTable = TomlTable([])
      while (true) {
        match (buffer) {
          [ Comma, ...rest ] => {
            buffer = rest
            canDoAnother = true
          },
          [ Cbc, ...rest ] => {
            buffer = rest
            break
          },
          // TODO: Handle Keys With Strings
          [ Literal(keyName), Eq, ...rest ] when canDoAnother => {
            canDoAnother = false
            buffer = rest
            // Validate Key Name
            if (!isValidKeyTable(keyName)) fail "Invalid Key Name"
            // Parse The Value
            let (value, rest) = parseValue(rest)
            buffer = rest
            // Write To Current Table
            rootTable = writeTable(rootTable, parseKey(keyName), value)
          },
          // Invalid
          _ => fail "Invalid Toml Object"
        }
      }
      if (canDoAnother) fail "Invalid Trailing Comma In Table"
      (rootTable, buffer)
    },
    // Inline-Array
    [ Sbo, ...rest ] => {
      let mut buffer = rest
      let mut values = []
      // Parse Values
      let mut canDoAnother = true
      while (true) {
        match (buffer) {
          [ LineBreak, ...rest ] => {
            buffer = rest
          },
          [ Comma, ...rest ] => {
            buffer = rest
            canDoAnother = true
          },
          [ Sbc, ...rest ] => {
            buffer = rest
            break
          },
          _ when canDoAnother => {
            canDoAnother = false
            let (value, rest) = parseValue(buffer)
            buffer = rest
            values = [ value, ...values]
          },
          // Invalid
          _ => fail "Invalid Toml Array"
        }
      }
      (TomlArray(List.reverse(values)), buffer)
    },
    // Strings
    [ SingleQuote, Literal(literal), SingleQuote, ...rest ] => (TomlString(literal), rest),
    [ SingleQuote, SingleQuote, SingleQuote, Literal(literal), SingleQuote, SingleQuote, SingleQuote, ...rest ] => (TomlString(literal), rest),
    // TODO: Handle Escaping
    [ DoubleQuote, Literal(literal), DoubleQuote, ...rest ] => (TomlString(literal), rest),
    // TODO: Handle Escaping
    // TODO: Handle Trimming
    // TODO: Handle Newline Backslash
    [ DoubleQuote, DoubleQuote, DoubleQuote, Literal(literal), DoubleQuote, DoubleQuote, DoubleQuote, ...rest ] => (TomlString(literal), rest),
    // Parse Literals
    [Literal(bool),...rest] when String.trim(bool) == "true" => (TomlBoolean(true), rest),
    [Literal(bool),...rest] when String.trim(bool) == "false" => (TomlBoolean(false), rest),
    // TODO: DateTime
    // Float
    [Literal(int),...rest] when isFloat(int) => {
      match (Number.parseFloat(int)) {
        Ok(int) => (TomlFloat(int), rest),
        Err(_) => fail "Invalid Toml Float"
      }
    },
    // Number
    [Literal(int),...rest] when isNumber(int) => {
      match (Number.parseInt(int, 10)) {
        Ok(int) => (TomlInteger(int), rest),
        Err(_) => fail "Invalid Toml Integer"
      }
    },
    // Unknown
    _ => fail "Unknown Value"
  }
}
let parseFile = (buffer) => {
  let mut buffer = buffer
  let mut keyPath = []
  let mut rootTable = TomlTable([])
  while (List.length(buffer) > 0) {
    // Expressions
    match (buffer) {
      // Table
      [ Sbo, Literal(tableName), Sbc, ...rest ] => {
        buffer = rest
        // Validate Table name
        if (!isValidKeyTable(tableName)) fail "Invalid Table Name"
        // Write Table Name
        keyPath = parseKey(tableName)
        // Write To Current Table
        rootTable = writeTable(rootTable, keyPath, TomlTable([]))
      },
      // TODO: Table Array
      [ Sbo, Sbo, Literal(tableName), Sbc, Sbc, ...rest ] => {
        buffer = rest
        // Validate Table name
        if (!isValidKeyTable(tableName)) fail "Invalid Table Name"
        // TODO: Write Table Name
      },
      // Key Value
      [ Literal(keyName), Eq, ...rest ] => {
        buffer = rest
        // Validate Key Name
        if (!isValidKeyTable(keyName)) fail "Invalid Key Name"
        // Parse Key
        let key = List.append(keyPath, parseKey(keyName))
        // Parse The Value
        let (value, rest) = parseValue(rest)
        buffer = rest
        // Write To Current Table
        rootTable = writeTable(rootTable, key, value)
      },
      // Line Break
      [ LineBreak, LineBreak, ...rest ] => {
        buffer = rest
        // Reset Current Table Name
        keyPath = []
      },
      [ LineBreak, ...rest ] => buffer = rest,
      // Invalid
      _ => fail "Invalid Toml"
    }
  }
  // Return Table
  rootTable
}
// Public Api
provide let fromString = (str) => {
  let lexed = Lexer.lex(str)
  let parsed = parseFile(lexed)
  // Return Parsed
  parsed
}
// Assert
print(fromString("[test]\n\ntest2 = [ 'test',\n\n'test' ]"))
print(fromString("[test]\ntest2 = { test = 'test' }"))
