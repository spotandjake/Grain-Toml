module Toml

include "string"
include "char"
include "list"
include "buffer"
include "uint8"
include "number"
include "array"
include "map"
include "runtime/unsafe/wasmi32"
include "runtime/numberUtils"
include "runtime/string" as RunTimeString
include "runtime/numbers"
include "runtime/dataStructures"
from RunTimeString use { toString as runtimeToString }
from Numbers use { coerceNumberToWasmI32 }
from DataStructures use { tagSimpleNumber }
// Types
enum NumberOrDateOrTime {
  IsNumberLiteral,
  IsDateLiteral,
  IsTimeLiteral,
}
enum TableKeyHolds {
  KeyHoldsArray,
  KeyHoldsTable,
  KeyHoldsValue,
}
provide enum Toml {
  TomlTable(List<(String, Toml)>),
  TomlArray(List<Toml>),
  TomlString(String),
  TomlInt(Number),
  TomlFloat(Number),
  TomlBool(Bool),
  TomlDateTime(String),
  TomlDateTimeLocal(String),
  TomlDateLocal(String),
  TomlTimeLocal(String),
}
/**
 * Represents errors for TOML parsing along with a human readable text message.
 */
provide enum TOMLParseError {
  UnexpectedEndOfInput(String),
  UnexpectedToken(String),
  // TODO: Add Error Messages To All Of These, Along With Positions
  UnexpectedEndOfString,
  TomlInvalidTableWrite,
  TomlInvalidKey,
  DuplicateTomlKey,
  // TODO: Use A String Here Holding The U+xxxxxx value
  InvalidUnicodeScalar(Number),
}

/**
 * Internal data structure used during parsing.
 */
record TOMLParserState {
  string: String,
  bufferParse: Buffer.Buffer,
  mut currentCodePoint: Number,
  mut pos: Number,
  mut bytePos: Number,
}
exception MalformedUnicode
// Internals
let saveTomlState = parserState => {
  (parserState.currentCodePoint, parserState.pos, parserState.bytePos)
}
let restoreTomlState = ((currentCodePoint, pos, bytePos), parserState) => {
  parserState.currentCodePoint = currentCodePoint
  parserState.pos = pos
  parserState.bytePos = bytePos
}
let _END_OF_INPUT = -1
@unsafe
let toHex = (n: Number) => {
  let x = coerceNumberToWasmI32(n)
  NumberUtils.itoa32(x, 16n)
}
let toHexWithZeroPadding = (n: Number, padTo: Number) => {
  // Note that this function is only called in exceptional cases so no effort
  // was made to optimize it.
  let mut result = toHex(n)
  while (String.length(result) < padTo) {
    result = "0" ++ result
  }
  result
}
let formatCodePointOrEOF = (codePoint: Number) => {
  if (codePoint >= 32 && codePoint <= 126) {
    // If the codepoint is in the range of printable ASCII charactes, then
    // display the character itself . Whether it's a good idea to display
    // all of them, especially space is up for debate.
    "'" ++ runtimeToString(Char.fromCode(codePoint)) ++ "'"
  } else if (codePoint == -1) {
    // Special case for value used by the parsing code to avoid heap allocations.
    "end of input"
  } else {
    // Format any other code point as hexadecimal value.
    "U+" ++ toHexWithZeroPadding(codePoint, 4)
  }
}
// TODO: Make this take unexpected and expected for better consistency
let buildUnexpectedTokenError =
  (
    parserState: TOMLParserState,
    detail: String,
  ) => {
  let codePoint = parserState.currentCodePoint
  let pos = parserState.pos
  if (codePoint == _END_OF_INPUT) {
    UnexpectedEndOfInput(
      "Unexpected token at position " ++ runtimeToString(pos) ++ ": " ++ detail
    )
  } else {
    UnexpectedToken(
      "Unexpected token at position " ++ runtimeToString(pos) ++ ": " ++ detail
    )
  }
}
// This function has been copied from the String module as a temporary
// solution. This will likely be replaced by a more robust solution for
// iterating over strings in the near future.
@unsafe
let getCodePoint = (ptr: WasmI32) => {
  // Algorithm from https://encoding.spec.whatwg.org/#utf-8-decoder
  from WasmI32 use {
    add as (+),
    and as (&),
    or as (|),
    shl as (<<),
    leU as (<=),
    geU as (>=),
    eq as (==),
  }

  let mut codePoint = 0n
  let mut bytesSeen = 0n
  let mut bytesNeeded = 0n
  let mut lowerBoundary = 0x80n
  let mut upperBoundary = 0xBFn

  let mut offset = 0n

  while (true) {
    let byte = WasmI32.load8U(ptr + offset, 0n)
    offset += 1n
    if (bytesNeeded == 0n) {
      if (byte >= 0x00n && byte <= 0x7Fn) {
        return byte
      } else if (byte >= 0xC2n && byte <= 0xDFn) {
        bytesNeeded = 1n
        codePoint = byte & 0x1Fn
      } else if (byte >= 0xE0n && byte <= 0xEFn) {
        if (byte == 0xE0n) lowerBoundary = 0xA0n
        if (byte == 0xEDn) upperBoundary = 0x9Fn
        bytesNeeded = 2n
        codePoint = byte & 0xFn
      } else if (byte >= 0xF0n && byte <= 0xF4n) {
        if (byte == 0xF0n) lowerBoundary = 0x90n
        if (byte == 0xF4n) upperBoundary = 0x8Fn
        bytesNeeded = 3n
        codePoint = byte & 0x7n
      } else {
        throw MalformedUnicode
      }
      continue
    }
    if (!(lowerBoundary <= byte && byte <= upperBoundary)) {
      throw MalformedUnicode
    }
    lowerBoundary = 0x80n
    upperBoundary = 0xBFn
    codePoint = codePoint << 6n | byte & 0x3Fn
    bytesSeen += 1n
    if (bytesSeen == bytesNeeded) {
      return codePoint
    }
  }
  return 0n
}

@unsafe
let rec readCodePoint = (bytePosition: Number, string: String) => {
  from WasmI32 use { add as (+), ltU as (<) }

  let strPtr = WasmI32.fromGrain(string)

  let byteSize = WasmI32.load(strPtr, 4n)

  let bytePositionW32 = coerceNumberToWasmI32(bytePosition)

  let ptr = strPtr + 8n + bytePositionW32

  let mut idx = 0n

  if (bytePositionW32 < byteSize) {
    let codePoint = getCodePoint(ptr)
    tagSimpleNumber(codePoint)
  } else {
    _END_OF_INPUT
  }
}

let codePointUTF8ByteCount = (usv: Number) => {
  if (!Char.isValid(usv)) {
    throw InvalidArgument("Invalid unicode scalar value")
  }

  if (usv <= 127) {
    1
  } else if (usv <= 2047) {
    2
  } else if (usv <= 65535) {
    3
  } else {
    4
  }
}

let isAtEndOfInput = (parserState: TOMLParserState) => {
  parserState.currentCodePoint == _END_OF_INPUT
}

let next = (parserState: TOMLParserState) => {
  let mut c = parserState.currentCodePoint
  if (c != _END_OF_INPUT) {
    parserState.bytePos += codePointUTF8ByteCount(c)

    c = readCodePoint(parserState.bytePos, parserState.string)

    parserState.currentCodePoint = c
    parserState.pos += 1
  }
  c
}
let expectCodePointAndAdvance =
  (
    expectedCodePoint: Number,
    parserState: TOMLParserState,
  ) => {
  let c = parserState.currentCodePoint
  if (c == expectedCodePoint) {
    next(parserState)
    None
  } else {
    let detail = "expected " ++
      formatCodePointOrEOF(expectedCodePoint) ++
      ", found " ++
      formatCodePointOrEOF(c)
    Some(buildUnexpectedTokenError(parserState, detail))
  }
}
let isCurrentTokenNewLine = (parserState: TOMLParserState) => {
  match (parserState.currentCodePoint) {
    0x0A => true, // line feed
    0x0D => { // carriage return
      let startState = saveTomlState(parserState)
      next(parserState)
      let isCRLF = parserState.currentCodePoint == 0x0A
      restoreTomlState(startState, parserState)
      isCRLF
    },
    _ => false,
  }
}
let isCurrentTokenSpace = (parserState: TOMLParserState) => {
  match (parserState.currentCodePoint) {
    0x09 => true, // tab
    0x20 => true, // space
    _ => false,
  }
}
let isCurrentTokenWhiteSpace = (parserState: TOMLParserState) => {
  isCurrentTokenSpace(parserState) || isCurrentTokenNewLine(parserState)
}
let isValidTomlChar = (codePoint: Number) => {
  let mut isValid = false
  // Ranges To Allow
  if (codePoint >= 0x01 && codePoint <= 0x09) isValid = true
  if (codePoint >= 0x0E && codePoint <= 0x7F) isValid = true
  if (codePoint >= 0x80 && codePoint <= 0xD7FF) isValid = true
  if (codePoint >= 0xE000 && codePoint <= 0x10FFFF) isValid = true
  // Ranges To Disallow
  // TODO: Determine what code points should actually be disallowed, I think its here https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf#G7404
  if (codePoint == 0xFFFD) isValid = false
  // Ensure Valid Grain Char
  if (!Char.isValid(codePoint)) isValid = false
  // Default True
  return isValid
}
let isValidCommentChar = (codePoint: Number) => {
  print(codePoint)
  if (!isValidTomlChar(codePoint)) return false
  if (codePoint == 0x00 || codePoint >= 0x0A && codePoint <= 0x0D) return false
  return true
}

let skipNewLine = (parserState: TOMLParserState) => {
  // isAtEndOfInput is not strictly necessary here
  // could remove as an optimization
  while (isCurrentTokenNewLine(parserState) && !isAtEndOfInput(parserState)) {
    if (parserState.currentCodePoint == 0x0D) { // '\r'
      next(parserState)
      void
    }
    next(parserState)
    void
  }
}
let skipSpace = (parserState: TOMLParserState) => {
  // isAtEndOfInput is not strictly necessary here
  // could remove as an optimization
  while (isCurrentTokenSpace(parserState) && !isAtEndOfInput(parserState)) {
    next(parserState)
    void
  }
}
let skipWhiteSpace = (parserState: TOMLParserState) => {
  // isAtEndOfInput is not strictly necessary here
  // could remove as an optimization
  while (
    isCurrentTokenWhiteSpace(parserState) &&
    !isAtEndOfInput(parserState)
  ) {
    next(parserState)
    void
  }
}
let addCharFromCodePoint = (codePoint: Number, buffer: Buffer.Buffer) => {
  Buffer.addChar(Char.fromCode(codePoint), buffer)
}
let atoiFast = buffer => {
  let bufLen = Buffer.length(buffer)
  let mut result = 0
  for (let mut i = 0; i < bufLen; i += 1) {
    from Uint8 use { (-) }
    result = (result << 1) +
      (result << 3) +
      Uint8.toNumber(Buffer.getUint8(i, buffer) - 48us)
  }
  result
}
// Toml Table
let rec writeTable =
  (
    tablePath,
    tableElement,
    rootTable,
    writeArray,
    overWrite=true,
  ) => {
  match (tablePath) {
    [pathItem] when writeArray => {
      match (rootTable) {
        TomlTable(tableItems) => {
          // Find Path Item
          let pathItemIndex = List.findIndex(((key, _)) =>
            key == pathItem, tableItems)
          let (tableKey, tableValue) = match (pathItemIndex) {
            Some(pathItemIndex) => {
              match (List.nth(pathItemIndex, tableItems)) {
                Some(item) => item,
                None => fail "Impossible5",
              }
            },
            None => (pathItem, TomlArray([])),
          }
          // Ensure Our Value Is an Array
          match (tableValue) {
            TomlArray(arrItems) => {
              // TODO: Find a more efficent way of doing this
              let arrItems = List.append(arrItems, [tableElement])
              let tableItems = match (pathItemIndex) {
                Some(pathItemIndex) => {
                  // TODO: Find a faster way todo this
                  let arr = Array.fromList(tableItems)
                  arr[pathItemIndex] = (pathItem, TomlArray(arrItems))
                  Array.toList(arr)
                },
                // TODO: Find a faster way of doing this
                None =>
                  List.append(tableItems, [(pathItem, TomlArray(arrItems))]),
              }
              Ok(TomlTable(tableItems))
            },
            _ => Err(TomlInvalidTableWrite),
          }
        },
        _ => Err(TomlInvalidTableWrite),
      }
    },
    [pathItem, ...rest] => {
      match (rootTable) {
        TomlTable(tableItems) => {
          // Find Path Item
          let pathItemIndex = List.findIndex(((key, _)) =>
            key == pathItem, tableItems)
          if (rest == [] && !overWrite && pathItemIndex != None) {
            Ok(TomlTable(tableItems))
          } else {
            let (tableKey, tableValue) = match (pathItemIndex) {
              Some(pathItemIndex) => {
                match (List.nth(pathItemIndex, tableItems)) {
                  Some(item) => item,
                  None => fail "Impossible5",
                }
              },
              None => (pathItem, TomlTable([])),
            }
            match (writeTable(rest, tableElement, tableValue, writeArray, overWrite=overWrite)) {
              Err(err) => Err(err),
              Ok(item) => {
                let tableItems = match (pathItemIndex) {
                  Some(pathItemIndex) => {
                    // TODO: Find a faster way todo this
                    let arr = Array.fromList(tableItems)
                    arr[pathItemIndex] = (pathItem, item)
                    Array.toList(arr)
                  },
                  // TODO: Find a faster way of doing this
                  None => List.append(tableItems, [(pathItem, item)]),
                }
                Ok(TomlTable(tableItems))
              },
            }
          }
        },
        _ => Err(TomlInvalidTableWrite),
      }
    },
    _ => Ok(tableElement),
  }
}

let skipComment = parserState => {
  let mut hasHitComment = false
  let mut hasHitNewLine = false
  while (!isAtEndOfInput(parserState)) {
    match (parserState.currentCodePoint) {
      // '#'
      0x23 => hasHitComment = true,
      // NewLine
      c when isCurrentTokenNewLine(parserState) => {
        hasHitNewLine = true
        break
      },
      // Space
      c when isCurrentTokenSpace(parserState) => void,
      // Anything else
      _ when !hasHitComment => break,
      c => {
        if (!isValidCommentChar(c)) {
          return Err(
            buildUnexpectedTokenError(
              parserState,
              "Unexpected Token In Comment: " ++ formatCodePointOrEOF(c)
            )
          )
        }
      },
    }
    next(parserState)
    void
  }
  return Ok((hasHitComment, hasHitNewLine))
}
// A-Za-z0-9_-
let isValidBareKeyChar = c =>
  c >= 0x41 && c <= 0x5A ||
    c >= 0x61 && c <= 0x7A ||
    c >= 0x30 && c <= 0x39 ||
    c == 0x5F ||
    c == 0x2D
// Parse
let rec parseKey = parserState => {
  Buffer.clear(parserState.bufferParse)
  let mut allowMore = true
  let mut allowStop = false
  let mut parsingBare = false
  let mut key = []
  let mut keyHasValue = false
  while (!isAtEndOfInput(parserState)) {
    match (parserState.currentCodePoint) {
      // '
      0x27 when allowMore && !parsingBare => {
        let str = match (parseLitStringLiteral(parserState, false)) {
          Ok(TomlString(str)) => str,
          Err(err) => return Err(err),
          _ => fail "Impossible7",
        }
        Buffer.clear(parserState.bufferParse)
        Buffer.addString(str, parserState.bufferParse)
        allowMore = false
        allowStop = true
        keyHasValue = true
      },
      // "
      0x22 when allowMore && !parsingBare => {
        let str = match (parseBasicStringLiteral(parserState, false)) {
          Ok(TomlString(str)) => str,
          Err(err) => return Err(err),
          _ => fail "Impossible6",
        }
        Buffer.clear(parserState.bufferParse)
        Buffer.addString(str, parserState.bufferParse)
        allowMore = false
        allowStop = true
        keyHasValue = true
      },
      // .
      0x2E => {
        keyHasValue = false
        parsingBare = false
        if (!allowStop) {
          let detail = "expected a A-Za-z0-9-_\"' digit, found ."
          return Err(buildUnexpectedTokenError(parserState, detail))
        }
        next(parserState)
        skipSpace(parserState)
        allowMore = true
        key = [Buffer.toString(parserState.bufferParse), ...key]
        Buffer.clear(parserState.bufferParse)
        allowStop = false
      },
      // Handle bare Key
      c when isValidBareKeyChar(c) && allowMore => {
        parsingBare = true
        next(parserState)
        addCharFromCodePoint(c, parserState.bufferParse)
        allowStop = true
        keyHasValue = true
      },
      // Handle Space
      c when isCurrentTokenSpace(parserState) => {
        next(parserState)
        allowMore = false
      },
      // Invalid Key Value
      c => break,
    }
  }
  if (keyHasValue == true) key = [Buffer.toString(parserState.bufferParse), ...key]
  if (List.length(key) == 0 && Buffer.length(parserState.bufferParse) == 0) {
    return Err(TomlInvalidKey)
  }
  // Return Key Path
  return Ok(List.reverse(key))
},
// Parse Literal
parseTrueLiteral = parserState => {
  match (expectCodePointAndAdvance(0x74, parserState)) {
    // 't'
    Some(e) => Err(e),
    None => {
      match (expectCodePointAndAdvance(0x72, parserState)) {
        // 'r'
        Some(e) => Err(e),
        None => {
          match (expectCodePointAndAdvance(0x75, parserState)) {
            // 'u'
            Some(e) => Err(e),
            None => {
              match (expectCodePointAndAdvance(0x65, parserState)) {
                // 'e'
                Some(e) => Err(e),
                None => Ok(TomlBool(true)),
              }
            },
          }
        },
      }
    },
  }
},
parseFalseLiteral = parserState => {
  match (expectCodePointAndAdvance(0x66, parserState)) {
    // 'f'
    Some(e) => Err(e),
    None => {
      match (expectCodePointAndAdvance(0x61, parserState)) {
        // 'a'
        Some(e) => Err(e),
        None => {
          match (expectCodePointAndAdvance(0x6C, parserState)) {
            // 'l'
            Some(e) => Err(e),
            None => {
              match (expectCodePointAndAdvance(0x73, parserState)) {
                // 's'
                Some(e) => Err(e),
                None => {
                  match (expectCodePointAndAdvance(0x65, parserState)) {
                    // 'e'
                    Some(e) => Err(e),
                    None => Ok(TomlBool(false)),
                  }
                },
              }
            },
          }
        },
      }
    },
  }
},
parseNumberLiteral = parserState => {
  let buffer = parserState.bufferParse
  Buffer.clear(buffer)
  // First char can optionally be a minus sign.
  let mut c = parserState.currentCodePoint
  let mut isFloat = false
  let mut base = 10
  let mut leadingZero = false
  let isNegative = c == 0x2D
  let hasLeadingPositive = c == 0x2B
  // '-' || '+'
  if (isNegative || hasLeadingPositive) {
    c = next(parserState)
  }
  // Handle Parsing Numeric Half
  // After that, the first/second char can only be a decimal digit ('0'..'9').
  match (c) {
    // nan
    0x6E => { // 'n'
      next(parserState)
      let result = match (expectCodePointAndAdvance(0x61, parserState)) {
        // 'a'
        Some(e) => Err(e),
        None => {
          match (expectCodePointAndAdvance(0x6E, parserState)) {
            // 'n'
            Some(e) => Err(e),
            None => Ok(TomlFloat(NaN)),
          }
        },
      }
      return result
    },
    // inf
    0x69 => { // 'i'
      next(parserState)
      let result = match (expectCodePointAndAdvance(0x6E, parserState)) {
        // 'n'
        Some(e) => Err(e),
        None => {
          match (expectCodePointAndAdvance(0x66, parserState)) {
            // 'f'
            Some(e) => Err(e),
            None => {
              if (isNegative)
                Ok(TomlFloat(Infinity * (if (isNegative) -1.0 else 1.0)))
              else
                Ok(TomlInt(Infinity))
            }
          }
        },
      }
      return result
    },
    0x30 => { // '0'
      // Toml doesn't allow numbers with additional leading zeros like
      // "01". Which means that if a number starts with zero then the
      // integer part is just zero and the next one can only be one of
      // '.', 'e' or 'E'. In any case all that needs to be done here is
      // to advance over the zero character and proceed to the optional
      // fractional and exponential parts. If another digit follows then
      // a parsing error will occur as expected, but implicitly because
      // this function finishes with the parser positioned on a digit
      // and not on a token expected after a number like ',', ']', '}' or
      // EOF.
      addCharFromCodePoint(c, buffer)
      c = next(parserState)
      leadingZero = true
    },
    x when x >= 0x31 && x <= 0x39 && base == 10 => { // '1'..'9'
      let mut lastDigit = false
      let mut allowUnderScore = false
      for (;;) {
        if (c == 0x5F) {
          if (!allowUnderScore) {
            let detail = "unexpected '_' in number"
            return Err(buildUnexpectedTokenError(parserState, detail))
          }
          allowUnderScore = false
        } else {
          allowUnderScore = true
        }
        if (c != 0x5F) addCharFromCodePoint(c, buffer)
        c = next(parserState)
        if (c < 0x30 || c > 0x39 && c != 0x5F) {
          break
        }
      }
      if (!allowUnderScore) {
        let detail = "unexpected '_' in number"
        return Err(buildUnexpectedTokenError(parserState, detail))
      }
      void
    },
    unexpectedCodePoint => {
      // The integer part of the number has to have at least one digit.
      // JSON doesn't allow numbers starting with decimal separator like ".1".
      let detail = "expected a decimal digit, found " ++
        formatCodePointOrEOF(unexpectedCodePoint)
      return Err(buildUnexpectedTokenError(parserState, detail))
    },
  }
  // Handle Other Number Types
  if (leadingZero && !isNegative && !hasLeadingPositive) {
    match (c) {
      0x78 => { // 'x'
        Buffer.addChar('x', buffer)
        base = 16
        c = next(parserState)
        let mut i = 0
        let mut allowUnderScore = false
        for (
          ;
          c >= 0x30 && c <= 0x39 ||
          c >= 0x41 && c <= 0x46 ||
          c >= 0x61 && c <= 0x66 ||
          c == 0x5F;
          i += 1
        ) {
          if (c == 0x5F) {
            if (!allowUnderScore) {
              let detail = "unexpected '_' in number"
              return Err(buildUnexpectedTokenError(parserState, detail))
            }
            allowUnderScore = false
          } else {
            allowUnderScore = true
          }
          addCharFromCodePoint(c, buffer)
          c = next(parserState)
        }
        if (!allowUnderScore) {
          let detail = "unexpected '_' in number"
          return Err(buildUnexpectedTokenError(parserState, detail))
        }
        if (i == 0) {
          let detail = "expected a hex digit, found " ++ formatCodePointOrEOF(c)
          return Err(buildUnexpectedTokenError(parserState, detail))
        }
      },
      0x6F => { // 'o'
        Buffer.addChar('o', buffer)
        base = 8
        c = next(parserState)
        let mut i = 0
        let mut allowUnderScore = false
        for (; c >= 0x30 && c <= 0x37 || c == 0x5F; i += 1) {
          if (c == 0x5F) {
            if (!allowUnderScore) {
              let detail = "unexpected '_' in number"
              return Err(buildUnexpectedTokenError(parserState, detail))
            }
            allowUnderScore = false
          } else {
            allowUnderScore = true
          }
          addCharFromCodePoint(c, buffer)
          c = next(parserState)
        }
        if (!allowUnderScore) {
          let detail = "unexpected '_' in number"
          return Err(buildUnexpectedTokenError(parserState, detail))
        }
        if (i == 0) {
          let detail = "expected an octal digit, found " ++
            formatCodePointOrEOF(c)
          return Err(buildUnexpectedTokenError(parserState, detail))
        }
      },
      0x62 => { // 'b'
        Buffer.addChar('b', buffer)
        base = 2
        c = next(parserState)
        let mut i = 0
        let mut allowUnderScore = false
        for (; c >= 0x30 && c <= 0x31 || c == 0x5F; i += 1) {
          if (c == 0x5F) {
            if (!allowUnderScore) {
              let detail = "unexpected '_' in number"
              return Err(buildUnexpectedTokenError(parserState, detail))
            }
            allowUnderScore = false
          } else {
            allowUnderScore = true
          }
          addCharFromCodePoint(c, buffer)
          c = next(parserState)
        }
        if (!allowUnderScore) {
          let detail = "unexpected '_' in number"
          return Err(buildUnexpectedTokenError(parserState, detail))
        }
        if (i == 0) {
          let detail = "expected a binary digit, found " ++
            formatCodePointOrEOF(c)
          return Err(buildUnexpectedTokenError(parserState, detail))
        }
      },
      _ => void,
    }
  }
  // Optional fractional part of the number.
  if (base == 10 && c == 0x2E) { // '.'
    isFloat = true
    Buffer.addChar('.', buffer)
    c = next(parserState)
    let mut i = 0
    let mut allowUnderScore = false
    for (; c >= 0x30 && c <= 0x39 || c == 0x5F; i += 1) {
      if (c == 0x5F) {
        if (!allowUnderScore) {
          let detail = "unexpected '_' in number"
          return Err(buildUnexpectedTokenError(parserState, detail))
        }
        allowUnderScore = false
      } else {
        allowUnderScore = true
      }
      if (c != 0x5F) addCharFromCodePoint(c, buffer)
      c = next(parserState)
    }
    if (!allowUnderScore) {
      let detail = "unexpected '_' in number"
      return Err(buildUnexpectedTokenError(parserState, detail))
    }
    if (i == 0) {
      let detail = "expected a decimal digit, found " ++ formatCodePointOrEOF(c)
      return Err(buildUnexpectedTokenError(parserState, detail))
    }
  }
  // Optional exponential part of the number.
  if (base == 10 && c == 0x65 || c == 0x45) { // 'e' or 'E'
    isFloat = true
    Buffer.addChar('e', buffer)
    c = next(parserState)
    // can start with optional plus or minus sign
    match (c) {
      0x2D => { // '-'
        c = next(parserState)
        Buffer.addChar('-', buffer)
      },
      0x2B => { // '+'
        c = next(parserState)
      },
      _ => void,
    }
    // followed by one or more digits (0-9)
    let mut i = 0
    let mut allowUnderScore = false
    for (; c >= 0x30 && c <= 0x39 || c == 0x5F; i += 1) {
      if (c == 0x5F) {
        if (!allowUnderScore) {
          let detail = "unexpected '_' in number"
          return Err(buildUnexpectedTokenError(parserState, detail))
        }
        allowUnderScore = false
      } else {
        allowUnderScore = true
      }
      if (c != 0x5F) addCharFromCodePoint(c, buffer)
      c = next(parserState)
    }
    if (!allowUnderScore) {
      let detail = "unexpected '_' in number"
      return Err(buildUnexpectedTokenError(parserState, detail))
    }
    if (i == 0) {
      let detail = "expected a decimal digit, found " ++ formatCodePointOrEOF(c)
      return Err(buildUnexpectedTokenError(parserState, detail))
    }

    void
  }
  // Note that unlike all other Toml value types there's no explicit ending
  // character like ('"' for strings, ']' for arrays,'}' for objects etc). We
  // just leave the parser state at current position and the reading of next
  // token will succeed or fail, but number parsing just ends here.

  return match (isFloat) {
    false when base == 10 => {
      let result = atoiFast(buffer)
      Ok(TomlInt(if (isNegative) result * -1 else result))
    },
    false => {
      let str = Buffer.toString(buffer)
      match (Number.parseInt(str, base)) {
        Err(err) => fail "Impossible1",
        Ok(result) => {
          Ok(TomlInt(if (isNegative) result * -1 else result))
        },
      }
    },
    true => {
      let str = Buffer.toString(buffer)
      match (Number.parseFloat(str)) {
        Err(err) => fail "Impossible2",
        Ok(result) => {
          Ok(TomlFloat(if (isNegative) result * -1 else result))
        },
      }
    },
  }
},
// TODO: Consider Combining literal and basic string parsing to deduplicate code
parseBasicStringLiteral = (parserState, allowMultiLine) => {
  let strBuffer = parserState.bufferParse
  Buffer.clear(strBuffer)
  let mut hasHitContent = false
  let mut isMultiLine = false
  while (true) {
    match (parserState.currentCodePoint) {
      0x22 => { // '"'
        // TODO: Clean Up All The Quote Logic Here And For Lit String
        let mut quoteCount = 0
        while (parserState.currentCodePoint == 0x22) {
          next(parserState)
          quoteCount += 1
        }
        if (quoteCount > 6 || quoteCount == 6 && hasHitContent) {
          return Err(UnexpectedEndOfString)
        } else if (quoteCount == 2 && !hasHitContent) {
          break
        } else if (quoteCount == 6 && !hasHitContent) {
          break
        } else if (quoteCount == 1) {
          if (isMultiLine) {
            Buffer.addChar('"', strBuffer)
          } else {
            if (hasHitContent) break
          }
        } else if (quoteCount >= 3) {
          if (!allowMultiLine) {
            return Err(
              buildUnexpectedTokenError(
                parserState,
                "Multi-line string literal not allowed here"
              )
            )
          }
          for (let mut i = 3; i < quoteCount; i += 1) {
            Buffer.addChar('"', strBuffer)
          }
          if (hasHitContent) break else isMultiLine = true
        } else {
          for (let mut i = 0; i < quoteCount; i += 1) {
            Buffer.addChar('"', strBuffer)
          }
        }
      },
      // Escape Chars
      0x5C => { // '\'
        hasHitContent = true
        next(parserState)
        match (parserState.currentCodePoint) {
          0x62 => { // 'b'
            next(parserState)
            Buffer.addChar('\u0008', strBuffer) // BackSpace
          },
          0x74 => { // 't'
            next(parserState)
            Buffer.addChar('\u0009', strBuffer) // Tab
          },
          0x6E => { // 'n'
            next(parserState)
            Buffer.addChar('\u000A', strBuffer) // LineFeed
          },
          0x66 => { // 'f'
            next(parserState)
            Buffer.addChar('\u000C', strBuffer) // FormFeed
          },
          0x72 => { // 'r'
            next(parserState)
            Buffer.addChar('\u000D', strBuffer) // CarriageReturn
          },
          0x65 => { // 'e'
            next(parserState)
            Buffer.addChar('\u001b', strBuffer) // CarriageReturn
          },
          0x22 => { // '"'
            next(parserState)
            Buffer.addChar('\u0022', strBuffer) // DoubleQuote
          },
          0x5C => { // '\'
            next(parserState)
            Buffer.addChar('\u005C', strBuffer) // Backslash
          },
          // \xHH       - unicode         (U+00HH)
          0x78 => { // 'u'
            next(parserState)
            let mut codeUnit = 0
            for (let mut digitIndex = 1; digitIndex >= 0; digitIndex -= 1) {
              let hexDigitCodePoint = parserState.currentCodePoint
              let mut digit = hexDigitCodePoint
              if (hexDigitCodePoint >= 48 && hexDigitCodePoint <= 57) { // 0..9
                digit -= 48
              } else if (
                hexDigitCodePoint >= 65 && hexDigitCodePoint <= 70
              ) { // A..F
                digit -= 55 // (65 - 10)
              } else if (
                hexDigitCodePoint >= 97 && hexDigitCodePoint <= 102
              ) { // a..f
                digit -= 87 // (97 - 10)
              } else {
                let digitsSoFar = 3 - digitIndex
                let detail = "expected exactly 2 hexadecimal digits in the UTF-8 escape sequence, found only " ++
                  runtimeToString(digitsSoFar)
                return Err(buildUnexpectedTokenError(parserState, detail))
              }
              let shift = digitIndex * 4
              codeUnit = codeUnit | digit << shift
              next(parserState)
              void
            }
            if (!Char.isValid(codeUnit))
              return Err(InvalidUnicodeScalar(codeUnit))
            Buffer.addChar(Char.fromCode(codeUnit), strBuffer)
          },
          // \uXXXX     - unicode         (U+XXXX)
          0x75 => { // 'u'
            next(parserState)
            let mut codeUnit = 0
            for (let mut digitIndex = 3; digitIndex >= 0; digitIndex -= 1) {
              let hexDigitCodePoint = parserState.currentCodePoint
              let mut digit = hexDigitCodePoint
              if (hexDigitCodePoint >= 48 && hexDigitCodePoint <= 57) { // 0..9
                digit -= 48
              } else if (
                hexDigitCodePoint >= 65 && hexDigitCodePoint <= 70
              ) { // A..F
                digit -= 55 // (65 - 10)
              } else if (
                hexDigitCodePoint >= 97 && hexDigitCodePoint <= 102
              ) { // a..f
                digit -= 87 // (97 - 10)
              } else {
                let digitsSoFar = 3 - digitIndex
                let detail = "expected exactly 4 hexadecimal digits in the UTF-8 escape sequence, found only " ++
                  runtimeToString(digitsSoFar)
                return Err(buildUnexpectedTokenError(parserState, detail))
              }
              let shift = digitIndex * 4
              codeUnit = codeUnit | digit << shift
              next(parserState)
              void
            }
            if (!Char.isValid(codeUnit))
              return Err(InvalidUnicodeScalar(codeUnit))
            Buffer.addChar(Char.fromCode(codeUnit), strBuffer)
          },
          // \UXXXXXXXX - unicode         (U+XXXXXXXX)
          0x55 => { // 'U'
            next(parserState)
            let mut codeUnit = 0
            for (let mut digitIndex = 7; digitIndex >= 0; digitIndex -= 1) {
              let hexDigitCodePoint = parserState.currentCodePoint
              let mut digit = hexDigitCodePoint
              if (hexDigitCodePoint >= 48 && hexDigitCodePoint <= 57) { // 0..9
                digit -= 48
              } else if (
                hexDigitCodePoint >= 65 && hexDigitCodePoint <= 70
              ) { // A..F
                digit -= 55 // (65 - 10)
              } else if (
                hexDigitCodePoint >= 97 && hexDigitCodePoint <= 102
              ) { // a..f
                digit -= 87 // (97 - 10)
              } else {
                let digitsSoFar = 3 - digitIndex
                let detail = "expected exactly 8 hexadecimal digits in the UTF-8 escape sequence, found only " ++
                  runtimeToString(digitsSoFar)
                return Err(buildUnexpectedTokenError(parserState, detail))
              }
              let shift = digitIndex * 4
              codeUnit = codeUnit | digit << shift
              next(parserState)
              void
            }
            if (!Char.isValid(codeUnit))
              return Err(InvalidUnicodeScalar(codeUnit))
            Buffer.addChar(Char.fromCode(codeUnit), strBuffer)
          },
          // Handle Trailing \
          c when isCurrentTokenWhiteSpace(parserState) => {
            let mut valid = false
            while (true) {
              if (isCurrentTokenNewLine(parserState)) {
                if (parserState.currentCodePoint == 0x0D) { // '\r'
                  next(parserState)
                  void
                }
                valid = true
              }
              if (!isCurrentTokenWhiteSpace(parserState)) {
                if (!valid) {
                  let c = parserState.currentCodePoint
                  let detail = "invalid escape sequence in string literal: " ++
                    formatCodePointOrEOF(c)
                  return Err(buildUnexpectedTokenError(parserState, detail))
                } else {
                  break
                }
              }
              next(parserState)
              void
            }
          },
          // Invalid
          _ => {
            let detail = "invalid escape sequence in string literal: " ++
              formatCodePointOrEOF(parserState.currentCodePoint)
            return Err(buildUnexpectedTokenError(parserState, detail))
          },
        }
      },
      // Invalid Chars
      c when (
        c >= 0x00 && c <= 0x0008 || c >= 0x000A && c <= 0x001F || c == 0x007F
      ) => {
        // TODO: Handle CRLF
        if (isMultiLine && c == 0x000A) {
          if (hasHitContent) addCharFromCodePoint(c, strBuffer)
          hasHitContent = true
          next(parserState)
          void
        } else {
          let detail = "invalid character in string literal: " ++
            formatCodePointOrEOF(c)
          return Err(buildUnexpectedTokenError(parserState, detail))
        }
      },
      // Unexpected End Of Input
      _ when isAtEndOfInput(parserState) => {
        return Err(
          UnexpectedEndOfInput("unexpected end of input in string literal")
        )
      },
      // Valid Chars
      c => {
        if (!isValidTomlChar(c)) {
          let detail = "invalid character in string literal: " ++
            formatCodePointOrEOF(c)
          return Err(buildUnexpectedTokenError(parserState, detail))
        }
        hasHitContent = true
        next(parserState)
        addCharFromCodePoint(c, strBuffer)
      },
    }
  }
  return Ok(TomlString(Buffer.toString(strBuffer)))
},
parseLitStringLiteral = (parserState, allowMultiLine) => {
  let strBuffer = parserState.bufferParse
  Buffer.clear(strBuffer)
  let mut hasHitContent = false
  let mut isMultiLine = false
  while (true) {
    match (parserState.currentCodePoint) {
      0x27 => { // '''
        // TODO: Clean Up Quote Logic
        let mut quoteCount = 0
        while (parserState.currentCodePoint == 0x27) {
          next(parserState)
          quoteCount += 1
        }
        if (quoteCount > 6 || quoteCount == 6 && hasHitContent) {
          return Err(UnexpectedEndOfString)
        } else if (quoteCount == 2 && !hasHitContent) {
          break
        } else if (quoteCount == 6 && !hasHitContent) {
          break
        } else if (quoteCount == 1) {
          if (isMultiLine) {
            Buffer.addChar('\'', strBuffer)
          } else {
            if (hasHitContent) break
          }
        } else if (quoteCount >= 3) {
          if (!allowMultiLine) {
            return Err(
              buildUnexpectedTokenError(
                parserState,
                "Multi-line string literal not allowed here"
              )
            )
          }
          for (let mut i = 3; i < quoteCount; i += 1) {
            Buffer.addChar('\'', strBuffer)
          }
          if (hasHitContent) break else isMultiLine = true
        } else {
          for (let mut i = 0; i < quoteCount; i += 1) {
            Buffer.addChar('\'', strBuffer)
          }
        }
      },
      // Invalid Chars
      c when (
        c >= 0x00 && c <= 0x0008 || c >= 0x000A && c <= 0x001F || c == 0x007F
      ) => {
        // TODO: Handle CRLF
        if (isMultiLine && c == 0x000A) {
          if (hasHitContent) addCharFromCodePoint(c, strBuffer)
          hasHitContent = true
          next(parserState)
          void
        } else {
          let detail = "invalid character in string literal: " ++
            formatCodePointOrEOF(c)
          return Err(buildUnexpectedTokenError(parserState, detail))
        }
      },
      // Unexpected End Of Input
      _ when isAtEndOfInput(parserState) => {
        return Err(
          UnexpectedEndOfInput("unexpected end of input in string literal")
        )
      },
      // Valid Chars
      c => {
        if (!isValidTomlChar(c)) {
          let detail = "invalid character in string literal: " ++
            formatCodePointOrEOF(c)
          return Err(buildUnexpectedTokenError(parserState, detail))
        }
        hasHitContent = true
        next(parserState)
        addCharFromCodePoint(c, strBuffer)
      },
    }
  }
  return Ok(TomlString(Buffer.toString(strBuffer)))
},
parseArrayLiteral = parserState => {
  match (expectCodePointAndAdvance(0x5B, parserState)) {
    // '['
    Some(e) => return Err(e),
    None => void,
  }
  match (skipComment(parserState)) {
    Ok(_) => void,
    Err(err) => return Err(err),
  }
  skipWhiteSpace(parserState)
  let mut elems = []: List<Toml>

  let mut done = false
  let mut lastComment = true
  while (!done) {
    let c = parserState.currentCodePoint
    match (c) {
      0x2C when !lastComment => { // ','
        lastComment = true
        next(parserState)
        skipWhiteSpace(parserState)
      },
      0x5D => { // ']'
        next(parserState)
        done = true
        break
      },
      -1 => {
        // just end the loop without setting done to true
        break
      },
      _ when lastComment => {
        lastComment = false
        match (parseLiteral(parserState)) {
          Ok(elem) => {
            elems = [elem, ...elems]
            void
          },
          Err(e) => {
            return Err(e)
          },
        }
      },
      c => {
        let detail = "expected , found " ++ formatCodePointOrEOF(c)
        return Err(buildUnexpectedTokenError(parserState, detail))
      },
    }
    match (skipComment(parserState)) {
      Ok(_) => void,
      Err(err) => return Err(err),
    }
    skipWhiteSpace(parserState)
  }
  if (done) {
    return Ok(TomlArray(List.reverse(elems)))
  } else {
    return Err(
      buildUnexpectedTokenError(parserState, "unexpected end of array")
    )
  }
},
parseTableLiteral = parserState => {
  match (expectCodePointAndAdvance(0x7B, parserState)) {
    // '{'
    Some(e) => return Err(e),
    None => void,
  }
  let mut inlineTable = TomlTable([])
  // Parse Inside
  let mut requireMore = false
  while (true) {
    skipWhiteSpace(parserState)
    if (!requireMore) {
      // Check For End
      match (parserState.currentCodePoint) {
        0x7D => { // '}'
          next(parserState)
          break
        },
        -1 => {
          return Err(
            buildUnexpectedTokenError(parserState, "unexpected end of table")
          )
        },
        _ => void,
      }
    }
    requireMore = false
    //  Parse Key
    let key = match (parseKey(parserState)) {
      Ok(key) => key,
      Err(err) => return Err(err),
    }
    // Parse Equal
    match (expectCodePointAndAdvance(0x3D, parserState)) {
      // =
      Some(e) => return Err(e),
      None => void,
    }
    // Parse Value
    let value = match (parseLiteral(parserState)) {
      Ok(value) => value,
      Err(err) => return Err(err),
    }
    // TODO: Do Not Allow Duplicates
    inlineTable = match (writeTable(key, value, inlineTable, false)) {
      Ok(table) => table,
      Err(err) => return Err(err),
    }
    skipWhiteSpace(parserState)
    // Check For More
    match (parserState.currentCodePoint) {
      0x2C => { // ','
        next(parserState)
        void
      },
      0x7D => { // '}'
        next(parserState)
        break
      },
      -1 => {
        return Err(
          buildUnexpectedTokenError(parserState, "unexpected end of table")
        )
      },
      c => {
        return Err(
          buildUnexpectedTokenError(
            parserState,
            "expected ',' or '}' after value in table, found " ++
            formatCodePointOrEOF(c)
          )
        )
      },
    }
  }
  // Return Table
  return Ok(inlineTable)
},
parseDateLiteral = parserState => {
  // TODO: We should parse this to a series of numbers
  let buffer = parserState.bufferParse
  Buffer.clear(buffer)
  // Collect The Year
  for (let mut i = 0; i < 4; i += 1) {
    let c = parserState.currentCodePoint
    if (c < 0x30 || c > 0x39) {
      return Err(
        buildUnexpectedTokenError(
          parserState,
          "expected digit in date literal, found " ++ formatCodePointOrEOF(c)
        )
      )
    }
    addCharFromCodePoint(c, buffer)
    next(parserState)
    void
  }
  match (expectCodePointAndAdvance(0x2D, parserState)) {
    // '-'
    Some(e) => return Err(e),
    None => Buffer.addChar('-', buffer),
  }
  // Collect The Month
  for (let mut i = 0; i < 2; i += 1) {
    let c = parserState.currentCodePoint
    if (c < 0x30 || c > 0x39) {
      return Err(
        buildUnexpectedTokenError(
          parserState,
          "expected digit in date literal, found " ++ formatCodePointOrEOF(c)
        )
      )
    }
    addCharFromCodePoint(c, buffer)
    next(parserState)
    void
  }
  match (expectCodePointAndAdvance(0x2D, parserState)) {
    // '-'
    Some(e) => return Err(e),
    None => Buffer.addChar('-', buffer),
  }
  // Collect The Date
  for (let mut i = 0; i < 2; i += 1) {
    let c = parserState.currentCodePoint
    if (c < 0x30 || c > 0x39) {
      return Err(
        buildUnexpectedTokenError(
          parserState,
          "expected digit in date literal, found " ++ formatCodePointOrEOF(c)
        )
      )
    }
    addCharFromCodePoint(c, buffer)
    next(parserState)
    void
  }
  // Return The Date
  return Ok(TomlDateLocal(Buffer.toString(buffer)))
},
parseTimeLiteral = (parserState, allowSeconds=true) => {
  // TODO: We should parse this to a series of numbers
  let buffer = parserState.bufferParse
  Buffer.clear(buffer)
  // Collect The Hour
  for (let mut i = 0; i < 2; i += 1) {
    let c = parserState.currentCodePoint
    if (c < 0x30 || c > 0x39) {
      return Err(
        buildUnexpectedTokenError(
          parserState,
          "expected digit in time literal, found " ++ formatCodePointOrEOF(c)
        )
      )
    }
    addCharFromCodePoint(c, buffer)
    next(parserState)
    void
  }
  match (expectCodePointAndAdvance(0x3A, parserState)) {
    // ':'
    Some(e) => return Err(e),
    None => Buffer.addChar(':', buffer),
  }
  // Collect The Minute
  for (let mut i = 0; i < 2; i += 1) {
    let c = parserState.currentCodePoint
    if (c < 0x30 || c > 0x39) {
      return Err(
        buildUnexpectedTokenError(
          parserState,
          "expected digit in time literal, found " ++ formatCodePointOrEOF(c)
        )
      )
    }
    addCharFromCodePoint(c, buffer)
    next(parserState)
    void
  }
  if (allowSeconds) {
    // TODO: Make Seconds Optional
    match (expectCodePointAndAdvance(0x3A, parserState)) {
      // ':'
      Some(e) => return Err(e),
      None => Buffer.addChar(':', buffer),
    }
    // Collect The Second
    for (let mut i = 0; i < 2; i += 1) {
      let c = parserState.currentCodePoint
      if (c < 0x30 || c > 0x39) {
        return Err(
          buildUnexpectedTokenError(
            parserState,
            "expected digit in time literal, found " ++ formatCodePointOrEOF(c)
          )
        )
      }
      addCharFromCodePoint(c, buffer)
      next(parserState)
      void
    }
    // Collect The Second Fraction
    if (parserState.currentCodePoint == 0x2E) { // '.'
      next(parserState)
      Buffer.addChar('.', buffer)
      let mut c = parserState.currentCodePoint
      while (c >= 0x30 && c <= 0x39) {
        addCharFromCodePoint(c, buffer)
        c = next(parserState)
        void
      }
    }
  }
  // Return The Time
  return Ok(TomlTimeLocal(Buffer.toString(buffer)))
},
parseDateTimeLiteral = parserState => {
  // TODO: We should use numbers for this
  let tomlDate = parseDateLiteral(parserState)
  let tomlDate = match (tomlDate) {
    Ok(TomlDateLocal(d)) => d,
    Ok(_) => fail "Impossible",
    Err(e) => return Err(e),
  }
  // Check For Split
  match (parserState.currentCodePoint) {
    0x20 => void, // ' '
    0x54 => void, // 'T'
    0x74 => void, // 't'
    _ => return Ok(TomlDateLocal(tomlDate)),
  }
  next(parserState)
  // If We Have The Split Parse The Time
  let tomlTime = parseTimeLiteral(parserState)
  let tomlTime = match (tomlTime) {
    Ok(TomlTimeLocal(t)) => t,
    Ok(_) => fail "Impossible",
    Err(e) => return Err(e),
  }
  // Combine The Date Time
  let tomlDateTime = tomlDate ++ "T" ++ tomlTime
  // Check For Offset
  match (parserState.currentCodePoint) {
    0x5A | 0x7A => void, // 'Z'
    _ => {
      // Check For Numeric Offset
      match (parserState.currentCodePoint) {
        0x2B | 0x2D => { // '+' || '-'
          let sign = parserState.currentCodePoint
          next(parserState)
          let tomlTime = parseTimeLiteral(parserState, allowSeconds=false)
          let tomlTime = match (tomlTime) {
            Ok(TomlTimeLocal(t)) => t,
            Ok(_) => fail "Impossible",
            Err(e) => return Err(e),
          }
          let tomlDateTime = tomlDateTime ++
            Char.toString(Char.fromCode(sign)) ++
            tomlTime
          return Ok(TomlDateTime(tomlDateTime))
        },
        _ => return Ok(TomlDateTimeLocal(tomlDateTime)),
      }
    },
  }
  next(parserState)
  // Return The DateTime
  return Ok(TomlDateTime(tomlDateTime ++ "Z"))
},
parseNumberOrDateOrTime = parserState => {
  // TODO: Implement this into a parseNumberLike so we do not need to use a look ahead
  let literalStartState = saveTomlState(parserState)
  // Look Ahead To See What We Find
  let mut c = parserState.currentCodePoint
  let mut currentType = IsNumberLiteral
  for (let mut i = 0; i < 5; i += 1) {
    if (i == 2 && c == 0x3A) {
      currentType = IsTimeLiteral
    } else if (i == 4 && c == 0x2D) {
      currentType = IsDateLiteral
    } else if (c < 0x30 || c > 0x39) {
      currentType = IsNumberLiteral
    } else {
      c = next(parserState)
      continue
    }
    break
  }
  restoreTomlState(literalStartState, parserState)
  // Match The Current Type
  match (currentType) {
    IsNumberLiteral => parseNumberLiteral(parserState),
    IsDateLiteral => parseDateTimeLiteral(parserState),
    IsTimeLiteral => parseTimeLiteral(parserState),
  }
},
parseLiteral = parserState => {
  skipSpace(parserState)
  match (parserState.currentCodePoint) {
    0x74 => parseTrueLiteral(parserState), // 't'
    0x66 => parseFalseLiteral(parserState), // 'f'
    0x5B => parseArrayLiteral(parserState), // '['
    0x7B => parseTableLiteral(parserState), // '{'
    0x2B => parseNumberLiteral(parserState), // '+'
    0x2D => parseNumberLiteral(parserState), // '-'
    0x69 => parseNumberLiteral(parserState), // 'i'
    0x6E => parseNumberLiteral(parserState), // 'n'
    c when c >= 0x30 && c <= 0x39 =>
      parseNumberOrDateOrTime(parserState), // '0'..'9'
    0x22 => parseBasicStringLiteral(parserState, true), // '"'
    0x27 => parseLitStringLiteral(parserState, true), // '''
    c => {
      let detail = "expected start of a Toml value, found " ++
        formatCodePointOrEOF(c)
      Err(buildUnexpectedTokenError(parserState, detail))
    },
  }
}

// Parsing
let parseTableHeader = parserState => {
  next(parserState)
  let mut isArrayHeader = false
  if (parserState.currentCodePoint == 0x5B) {
    next(parserState)
    isArrayHeader = true
  }
  let key = match (parseKey(parserState)) {
    Ok(key) => key,
    Err(err) => return Err(err),
  }
  if (isArrayHeader) {
    match (expectCodePointAndAdvance(0x5D, parserState)) {
      Some(err) => return Err(err),
      None => void,
    }
  }
  match (expectCodePointAndAdvance(0x5D, parserState)) {
    Some(err) => return Err(err),
    None => void,
  }
  // Return Key
  return Ok((key, isArrayHeader))
}
let parseKeyValue = parserState => {
  //  Parse Key
  let key = match (parseKey(parserState)) {
    Ok(key) => key,
    Err(err) => return Err(err),
  }
  // Parse Equal
  match (expectCodePointAndAdvance(0x3D, parserState)) {
    // =
    Some(e) => return Err(e),
    None => void,
  }
  // Parse Value
  let value = match (parseLiteral(parserState)) {
    Ok(value) => value,
    Err(err) => return Err(err),
  }
  return Ok((key, value))
}
let parseFile = parserState => {
  // Create Our Table
  // TODO: Find A More Efficient Way Of Doing Key Validation
  let mut uniqueKeysRoot = Map.make()
  let mut uniqueKeysArray = Map.make()
  let mut rootTable = TomlTable([])
  let mut arrayTable = TomlTable([])
  let mut rootKey = []
  // Parse The File
  let mut needNewLine = false
  let mut writeArray = false
  let mut allowKeyValue = match (skipComment(parserState)) {
    Ok((hasHitComment, hasHitNewLine)) =>
      if (hasHitComment) hasHitNewLine else true,
    Err(err) => return Err(err),
  }
  while (!isAtEndOfInput(parserState)) {
    match (parserState.currentCodePoint) {
      // [
      0x5B =>
        match (parseTableHeader(parserState)) {
          Err(err) => return Err(err),
          Ok((key, isArrayHeader)) => {
            needNewLine = true
            // Write The Last Array
            if (writeArray) {
              rootTable = match (writeTable(
                rootKey,
                arrayTable,
                rootTable,
                true
              )) {
                Ok(t) => t,
                Err(err) => return Err(err),
              }
              arrayTable = TomlTable([])
              Map.clear(uniqueKeysArray)
              // Check For Duplicate Keys
              if (Map.get(key, uniqueKeysRoot) != None) {
                // TODO: Consider Improving This Error
                return Err(DuplicateTomlKey)
              }
              Map.set(key, KeyHoldsArray, uniqueKeysRoot)
            } else {
              // Check For Duplicate Keys
              if (Map.get(key, uniqueKeysRoot) != None) {
                // TODO: Consider Improving This Error
                return Err(DuplicateTomlKey)
              }
              Map.set(key, KeyHoldsTable, uniqueKeysRoot)
            }
            // Write Initial
            rootTable = match (writeTable(
              key,
              TomlTable([]),
              rootTable,
              false,
              overWrite=false
            )) {
              Ok(t) => t,
              Err(err) => return Err(err),
            }
            // Set The New Stuff
            writeArray = isArrayHeader
            rootKey = key
          },
        },
      c when isCurrentTokenWhiteSpace(parserState) =>
        skipWhiteSpace(parserState),
      c when !allowKeyValue => {
        return Err(
          buildUnexpectedTokenError(
            parserState,
            "expected \n found " ++ formatCodePointOrEOF(c)
          )
        )
      },
      _ => {
        match (parseKeyValue(parserState)) {
          Err(err) => return Err(err),
          Ok((path, value)) => {
            needNewLine = true
            // Get Write Info
            let (table, keyUniqueness, key) = match (writeArray) {
              true => (arrayTable, uniqueKeysArray, path),
              false => (rootTable, uniqueKeysRoot, List.append(rootKey, path)),
            }
            // Check For Duplicate Keys
            if (
              Map.get(key, keyUniqueness) != None && !writeArray ||
              Map.get(key, keyUniqueness) != Some(KeyHoldsArray) && writeArray
            ) {
              // TODO: Consider Improving This Error
              return Err(DuplicateTomlKey)
            }
            Map.set(key, KeyHoldsValue, keyUniqueness)
            // Write To Table
            let table = match (writeTable(key, value, table, false)) {
              Ok(t) => t,
              Err(err) => return Err(err),
            }
            match (writeArray) {
              true => arrayTable = table,
              false => rootTable = table,
            }
          },
        }
      },
    }
    allowKeyValue = match (skipComment(parserState)) {
      Ok((hasHitComment, hasHitNewLine)) => {
        if (needNewLine) {
          if (hasHitNewLine) needNewLine = false
          hasHitNewLine
        } else {
          if (hasHitComment) hasHitNewLine else true
        }
      },
      Err(err) => return Err(err),
    }
  }
  // Write Final Array
  if (writeArray) {
    let rootTable = match (writeTable(rootKey, arrayTable, rootTable, true)) {
      Ok(t) => t,
      Err(err) => return Err(err),
    }
  }
  // Return Our Table
  return Ok(rootTable)
}
// Entry
provide let fromString: String -> Result<Toml, TOMLParseError> =
  (
    str: String,
  ) => {
  let parserState = {
    string: str,
    bufferParse: Buffer.make(16),
    currentCodePoint: readCodePoint(0, str),
    pos: 0,
    bytePos: 0,
  }: TOMLParserState

  let root = parseFile(parserState)

  skipWhiteSpace(parserState)

  if (isAtEndOfInput(parserState)) {
    root
  } else {
    match (root) {
      Ok(_) => {
        let detail = "expected end of input, found " ++
          formatCodePointOrEOF(parserState.currentCodePoint)
        Err(buildUnexpectedTokenError(parserState, detail))
      },
      e => e,
    }
  }
}
