module Toml
include "string"
include "array"
include "list"
include "char"
include "number"
include "bytes"
// TODO: Use Err, instead of fail
// Type
enum LexerToken {
  // Fully Matched
  BasicString(String),
  BasicMultiLineString(String),
  LiteralString(String),
  LiteralMultiLineString(String),
  // Semi Matched
  Literal(String),
  Eq,
  Sbo,
  Cbo,
  Sbc,
  Cbc,
  Hash,
  DoubleQuote,
  SingleQuote,
  LineBreak,
  CarriageReturn,
  BackSlash,
  Comma,
  WhiteSpace,
}
// Stream
record Stream {
  data: Bytes,
  mut index: Number,
}
let streamFromString = (str) => {
  {
    data: Bytes.fromString(str),
    index: 0,
  }
}
let streamIsEmpty = (stream) => {
  (Bytes.length(stream.data) - stream.index) == 0
}
let streamPeekUint8 = (stream) => {
  let byte = Bytes.getUint8(stream.index, stream.data)
  byte
}
let streamNextUint8 = (stream) => {
  let byte = streamPeekUint8(stream)
  stream.index += 1
  byte
}
// Helpers
let getSpecialByte = (n) => {
  match (n) {
    0x3Dus => Some(Eq), // =
    0x5Bus => Some(Sbo), // [
    0x5Dus => Some(Sbc), // ]
    0x7Bus => Some(Cbo), // {
    0x7Dus => Some(Cbc), // }
    0x23us => Some(Hash), // #
    0x2Cus => Some(Comma), // ,
    0x27us => Some(SingleQuote), // '
    0x22us => Some(DoubleQuote), // "
    0x0Aus => Some(LineBreak), // \n
    0x0Dus => Some(CarriageReturn), // \r
    0x5Cus => Some(BackSlash), // \
    // WhiteSpace
    0x20us => Some(WhiteSpace), // Space
    0x09us => Some(WhiteSpace), // Tab
    _ => None,
  }
}
// Lex
let lex = (inputStr) => {
  let data = streamFromString(inputStr)
  let mut lexemes = []
  while (!streamIsEmpty(data)) {
    let byte = streamNextUint8(data)
    let lexValue = getSpecialByte(byte)
    match (lexValue) {
      Some(WhiteSpace) => continue,
      Some(Hash) => {
        while (!streamIsEmpty(data)) {
          let nextByte = streamPeekUint8(data)
          if (nextByte == 0x0Aus) break //\n
          else ignore(streamNextUint8(data))
        }
      },
      Some(quoteType) when quoteType == SingleQuote || quoteType == DoubleQuote => {
        // Collect Open Quotes
        let mut quoteCount = 1
        let mut isMultiLine = false
        while (!streamIsEmpty(data)) {
          let nextByte = streamPeekUint8(data)
          let nextValue = getSpecialByte(nextByte)
          match (nextValue) {
            Some(quote) when quote == quoteType => {
              streamNextUint8(data)
              quoteCount += 1
            },
            _ => break
          }
          if (quoteCount == 3) {
            isMultiLine = true
            break
          }
        }
        if (quoteCount == 2) {
          match (quoteType) {
            SingleQuote => lexemes = [ LiteralString(""), ...lexemes ],
            DoubleQuote => lexemes = [ BasicString(""), ...lexemes ],
            _ => fail "Invalid Toml Quote Type"
          }
        } else {
          let index = data.index
          let mut endIndex = 0
          // Match Quote's
          let maxQuoteCount = quoteCount
          while (!streamIsEmpty(data)) {
            let nextByte = streamNextUint8(data)
            let nextValue = getSpecialByte(nextByte)
            match (nextValue) {
              Some(BackSlash) => {
                if (!streamIsEmpty(data)) streamNextUint8(data)
                else fail "Invalid Toml BackSlash In String"
                endIndex += 1
                quoteCount = maxQuoteCount
              },
              Some(quote) when quote == quoteType => quoteCount -= 1,
              _ => quoteCount = maxQuoteCount
            }
            endIndex += 1
            if (quoteCount == 0) break
          }
          endIndex -= maxQuoteCount
          // Collect String
          let str = Bytes.slice(index, endIndex, data.data)
          let str = Bytes.toString(str)
          // Build Lexemes
          match (quoteType) {
            SingleQuote when isMultiLine => lexemes = [ LiteralMultiLineString(str), ...lexemes ],
            DoubleQuote when isMultiLine => lexemes = [ BasicMultiLineString(str), ...lexemes ],
            SingleQuote => lexemes = [ LiteralString(str), ...lexemes ],
            DoubleQuote => lexemes = [ BasicString(str), ...lexemes ],
            _ => fail "Invalid Toml Quote Type"
          }
        }
      },
      Some(CarriageReturn) => {
        let entry = if (!streamIsEmpty(data) && streamPeekUint8(data) == 0x0Aus) { // \n
          streamNextUint8(data)
          LineBreak
        } else CarriageReturn
        lexemes = [ entry, ...lexemes ]
      },
      Some(x) => lexemes = [ x, ...lexemes ],
      _ => {
        let index = data.index
        let mut alphabetic_index = 0
        while (!streamIsEmpty(data)) {
          let nextByte = streamPeekUint8(data)
          if (getSpecialByte(nextByte) == None) {
            streamNextUint8(data)
            alphabetic_index += 1
          } else {
            break
          }
        }
        let relative_index = alphabetic_index + 1
        let string_bytes = Bytes.slice(index-1, relative_index, data.data)
        let string = Bytes.toString(string_bytes)
        lexemes = [ Literal(string), ...lexemes ]
      }
    }
  }
  List.reverse(lexemes)
}
// Parser
provide enum TomlValue {
  TomlString(String),
  TomlInt(Number),
  TomlFloat(Number),
  TomlBool(Bool),
  TomlDateTime(String, String),
  TomlDate(String),
  TomlTime(String),
  TomlTable(List<(String, TomlValue)>),
  TomlArray(List<TomlValue>),
}
// Rewrite This Completely
let isValidKeyTable = (name) => {
  // TODO: Improve This
  Array.every((char) => {
    let charCode = Char.code(char)
    if (charCode >= Char.code('A') && charCode <= Char.code('Z')) {
      true
    } else if (charCode >= Char.code('a') && charCode <= Char.code('z')) {
      true
    } else if (charCode >= Char.code('0') && charCode <= Char.code('9')) {
      true
    } else if (char == '.') {
      true
    } else if (char == '-' || char == '_') {
      true
    } else {
      false
    }
  }, String.explode(String.trim(name)))
}
let parseKey = (key) => {
  // TODO: Handle Validation
  let key = Array.toList(String.explode(String.trim(key)))
  let mut closeString = ' '
  let mut keyPath = []
  let mut currentKey = ""
  List.forEach((char) => {
    // Handle String
    if (char == '\'' && closeString != '"') {
      if (closeString == '\'') closeString = ' '
      else if (closeString == ' ') closeString = '\''
      return
    } else if (char == '"' && closeString != '\'') {
      if (closeString == '"') closeString = ' '
      else if (closeString == ' ') closeString = '"'
      return
    }
    // Handle Writing Key
    if (char == '.' && closeString == ' ') {
      keyPath = [ currentKey, ...keyPath ]
      currentKey = ""
    } else currentKey = currentKey ++ Char.toString(char)
    return
  }, key)
  keyPath = [ currentKey, ...keyPath ]
  List.reverse(keyPath)
}
let rec writeTable = (rootTable, keyPath, value) => {
  // TODO: Rewrite This Completely
  // TODO: Validate This
  match (keyPath) {
    [ pathItem ] => match (rootTable) {
      TomlTable(tableContents) => {
        let hasKeyPath = List.some(((keyName, _)) => keyName == pathItem, tableContents)
        // If Value Is A Table Or Array Merge
        if (hasKeyPath) {
          let mut hasFoundItem = false
          TomlTable((List.map(((keyName, keyValue)) => {
            if (!hasFoundItem && keyName == pathItem) {
              hasFoundItem = true
              match (keyValue) {
                TomlTable(contents) => {
                  match (value) {
                    TomlTable(newContents) => {
                      (keyName, TomlTable(List.append(contents, newContents)))
                    },
                    _ => fail "Invalid Toml Table Write"
                  }
                },
                _ => fail "Invalid Toml Table Write"
              }
            } else (keyName, keyValue)
          }, tableContents)))
        } else {
          // Search Table
          TomlTable(List.append(tableContents, [ (pathItem, value) ]))
        }
      },
      _ => fail "Invalid Toml Array Write"
    },
    [ pathItem, ...rest ] => match (rootTable) {
      TomlTable(tableContents) => {
        // Search Table
        let hasSubTable = List.some(((keyName, _)) => keyName == pathItem, tableContents)
        match (hasSubTable) {
          true => {
            let mut hasWritten = false
            TomlTable(List.map(((keyName, keyValue)) => {
              if (keyName == pathItem && !hasWritten) {
                hasWritten = true
                (keyName, writeTable(keyValue, rest, value))
              } else (keyName, keyValue)
            }, tableContents))
          },
          false => {
            TomlTable(List.append(tableContents, [ (pathItem, writeTable(TomlTable([]), rest, value)) ]))
          }
        }
      },
      _ => fail "Invalid Toml Array Write"
    },
    [] => fail "Empty KeyPath"
  }
}
let isFloat = (str) => {
  // TODO: Validate This
  let lst = Array.toList(String.explode(String.trim(str)))
  // Allow +, -
  let mut posSign = false
  let lst = match (lst) {
    [ '+', ...rest ] => {
      posSign = true
      rest
    },
    [ '-', ...rest ] => rest,
    _ => lst
  }
  let isSpecial = match (lst) {
    [ 'n', 'a', 'n' ] => true,
    [ 'i', 'n', 'f' ] => true,
    _ => false
  }
  if (isSpecial) return true
  // Validation
  if (!List.contains('.', lst) && !List.contains('e', lst) && !List.contains('E', lst)) return false
  let mut lastChar = '_'
  let mut index = 0
  let lstLen = List.length(lst)
  let mut chosenStyle = 0
  let mut resetStyle = false
  return List.every((char) => {
    index += 1
    let charCode = Char.code(char)
    if (resetStyle && chosenStyle == 2) {
      if (char == '+' || char == '-') return true
    }
    resetStyle = false
    if (lastChar == '_' && char == '_') return false
    if (lstLen == index && char == '_') return false
    if (char == '_') return true
    lastChar = char
    // Integers
    if (charCode >= Char.code('0') && charCode <= Char.code('9')) return true
    // Decimal Or Exponent
    if (lstLen == index && char == '.') return false
    if (lstLen == index && char == 'e') return false
    if (lstLen == index && char == 'E') return false
    if (chosenStyle == 0) {
      if (char == '.') {
        chosenStyle = 1
        resetStyle = true
        if (lastChar == '_') return false
        lastChar = '_'
        return true
      }
    } else {
      if (char == '.') return false
    }
    if (chosenStyle == 0 || chosenStyle == 1) {
      if (char == 'e' || char == 'E') {
        chosenStyle = 2
        resetStyle = true
        if (lastChar == '_') return false
        lastChar = '_'
        return true
      }
    } else {
      if (char == 'e') return false
      if (char == 'E') return false
    }
    // Otherwise False
    return false
  }, lst)
}
let isNumber = (str) => {
  // TODO: Validate This
  let lst = Array.toList(String.explode(String.trim(str)))
  // Allow +, -
  let mut posSign = false
  let lst = match (lst) {
    [ '+', ...rest ] => {
      posSign = true
      rest
    },
    [ '-', ...rest ] => rest,
    _ => lst
  }
  // Match Type
  let mut numberRadix = 10
  let lst = match (lst) {
    // Hex
    [ '0', 'x', ...rest ] |
    [ '0', 'X', ...rest ] => {
      numberRadix = 16
      rest
    },
    // Octal
    [ '0', 'o', ...rest ] |
    [ '0', 'O', ...rest ] => {
      numberRadix = 8
      rest
    },
    // Binary
    [ '0', 'b', ...rest ] |
    [ '0', 'B', ...rest ] => {
      numberRadix = 2
      rest
    },
    // Rest
    _ => lst
  }
  if (posSign && numberRadix != 10) return false
  // Validation
  let mut lastChar = '_'
  let mut index = 0
  let lstLen = List.length(lst)
  return List.every((char) => {
    index += 1
    let charCode = Char.code(char)
    if (lastChar == '_' && char == '_') return false
    if (lstLen == index && char == '_') return false
    if (char == '_') return true
    lastChar = char
    if (numberRadix == 10) {
      if (charCode >= Char.code('0') && charCode <= Char.code('9')) return true
    } else if (numberRadix == 16) {
      if (charCode >= Char.code('0') && charCode <= Char.code('9')) return true
      else if (charCode >= Char.code('A') && charCode <= Char.code('Z')) return true
      else if (charCode >= Char.code('a') && charCode <= Char.code('z')) return true
    } else if (numberRadix == 8) {
      if (charCode >= Char.code('0') && charCode <= Char.code('7')) return true
    } else if (numberRadix == 2) {
      if (char == '0' || char == '1') return true
    }
    return false
  }, lst)
}
let escapeString = (str, isBasic, isMultiLine) => {
  // Normalize Line Ending
  let mut normalStr = ""
  let mut str = Array.toList(String.explode(str))
  while (true) {
    match (str) {
      // Handle Quick Escape Sequences
      [ '\r', '\n', ...rest ] => {
        normalStr = normalStr ++ "\n"
        str = rest
      },
      // Normal Chars
      [ item, ...rest ] => {
        normalStr = normalStr ++ Char.toString(item)
        str = rest
      },
      [] => break
    }
  }
  // Trim
  let mut escapedStr = ""
  let mut str = Array.toList(String.explode(normalStr))
  // Handle Trimming
  if (isMultiLine) {
    match (str) {
      [ '\n', ...rest ] => str = rest,
      _ => void
    }
  }
  // Handle Trimming
  if (isBasic && isMultiLine) {
    let mut tempStr = str
    str = []
    while (true) {
      match (tempStr) {
        [ '\\', '\\', ...rest] => {
          str = [ '\\', '\\', ...str ]
          tempStr = rest
        },
        [ '\\', ...rest ] => {
          let mut tempBuffer = rest
          let mut tempRest = rest
          let mut isNewLine = false
          while (true) {
            match (tempRest) {
              [ '\n', ...rest ] => {
                isNewLine = true
                tempRest = rest
              },
              [ ' ', ...rest ] => {
                tempBuffer = [ ' ', ...tempBuffer ]
                tempRest = rest
              },
              [ '\t', ...rest ] => {
                tempBuffer = [ '\t', ...tempBuffer ]
                tempRest = rest
              },
              [ n, ...rest ] => {
                // If Not Is NewLine
                if (isNewLine) {
                  tempStr = [ n, ...rest ]
                } else {
                  str = [ '\\', ...str ]
                  tempStr = tempBuffer
                }
                break
              },
              [] => {
                tempStr = []
                break
              }
            }
          }
        },
        [ item, ...rest ] => {
          str = [ item, ...str ]
          tempStr = rest
        },
        [] => break
      }
    }
    str = List.reverse(str)
  }
  // Handle Escaping
  while (true) {
    match (str) {
      // Handle Quick Escape Sequences
      [ '\\', 'b', ...rest ] when isBasic => { // Backspace
        escapedStr = escapedStr ++ "\u0008"
        str = rest
      },
      [ '\\', 't', ...rest ] when isBasic => { // Tab
        escapedStr = escapedStr ++ "\u0009"
        str = rest
      },
      [ '\\', 'n', ...rest ] when isBasic => { // LineFeed
        escapedStr = escapedStr ++ "\u000A"
        str = rest
      },
      [ '\\', 'f', ...rest ] when isBasic => { // FormFeed
        escapedStr = escapedStr ++ "\u000C"
        str = rest
      },
      [ '\\', 'r', ...rest ] when isBasic => { // Carriage Return
        escapedStr = escapedStr ++ "\u000D"
        str = rest
      },
      [ '\\', 'e', ...rest ] when isBasic => { // Escape
        escapedStr = escapedStr ++ "\u001B"
        str = rest
      },
      [ '\\', '"', ...rest ] when isBasic => { // Double Quote
        escapedStr = escapedStr ++ "\u0022"
        str = rest
      },
      [ '\\', '\\', ...rest ] when isBasic => { // BackSlash
        escapedStr = escapedStr ++ "\u005C"
        str = rest
      },
      // Unicode Escape Sequences
      [ '\\', 'x', d0, d1, ...rest] when isBasic => {
        let s = Char.toString(d0) ++ Char.toString(d1)
        let i = Number.parseInt(s, 16)
        match (i) {
          Ok (i) => escapedStr = escapedStr ++ Char.toString(Char.fromCode(i)),
          Err(_) => fail "TOML: Invalid Unicode Escape Sequence"
        }
        str = rest
      },
      [ '\\', 'u', d0, d1, d2, d3, ...rest] when isBasic => {
        let s = Char.toString(d0) ++ Char.toString(d1) ++ Char.toString(d2) ++ Char.toString(d3)
        let i = Number.parseInt(s, 16)
        match (i) {
          Ok (i) => escapedStr = escapedStr ++ Char.toString(Char.fromCode(i)),
          Err(_) => fail "TOML: Invalid Unicode Escape Sequence"
        }
        str = rest
      },
      [ '\\', 'U', d0, d1, d2, d3, d4, d5, d6, d7, ...rest] when isBasic => {
        let s = Char.toString(d0) ++ Char.toString(d1) ++ Char.toString(d2) ++ Char.toString(d3) ++ Char.toString(d4) ++ Char.toString(d5) ++ Char.toString(d6) ++ Char.toString(d7)
        let i = Number.parseInt(s, 16)
        match (i) {
          Ok (i) => escapedStr = escapedStr ++ Char.toString(Char.fromCode(i)),
          Err(_) => fail "TOML: Invalid Unicode Escape Sequence"
        }
        str = rest
      },
      // Normal Chars
      [ item, ...rest ] => {
        escapedStr = escapedStr ++ Char.toString(item)
        str = rest
      },
      [] => break
    }
  }
  // return escaped string
  escapedStr
}
// Parsers
let rec parseValue = (buffer) => {
  match (buffer) {
    // Objects
    // Inline-Table
    [ Cbo, ...rest ] => {
      let mut buffer = rest
      // Parse Values
      let mut canDoAnother = true
      let mut rootTable = TomlTable([])
      while (true) {
        match (buffer) {
          [ LineBreak, ...rest ] => {
            buffer = rest
          },
          [ Comma, ...rest ] => {
            buffer = rest
            canDoAnother = true
          },
          [ Cbc, ...rest ] => {
            buffer = rest
            break
          },
          // TODO: Handle Keys With Strings
          [ Literal(keyName), Eq, ...rest ] when canDoAnother => {
            canDoAnother = false
            buffer = rest
            // Validate Key Name
            if (!isValidKeyTable(keyName)) fail "Invalid Key Name"
            // Parse The Value
            let (value, rest) = parseValue(rest)
            buffer = rest
            // Write To Current Table
            rootTable = writeTable(rootTable, parseKey(keyName), value)
          },
          // Invalid
          _ => fail "Invalid Toml Object"
        }
      }
      (rootTable, buffer)
    },
    // Inline-Array
    [ Sbo, ...rest ] => {
      let mut buffer = rest
      let mut values = []
      // Parse Values
      let mut canDoAnother = true
      while (true) {
        match (buffer) {
          [ LineBreak, ...rest ] => {
            buffer = rest
          },
          [ Comma, ...rest ] => {
            buffer = rest
            canDoAnother = true
          },
          [ Sbc, ...rest ] => {
            buffer = rest
            break
          },
          _ when canDoAnother => {
            canDoAnother = false
            let (value, rest) = parseValue(buffer)
            buffer = rest
            values = [ value, ...values]
          },
          // Invalid
          _ => fail "Invalid Toml Array"
        }
      }
      (TomlArray(List.reverse(values)), buffer)
    },
    // Strings
    [ LiteralString(literal), ...rest ] => (TomlString(literal), rest),
    [ LiteralMultiLineString(literal), ...rest ] => (TomlString(escapeString(literal, false, true)), rest),
    [ BasicString(literal), ...rest ] => (TomlString(escapeString(literal, true, false)), rest),
    [ BasicMultiLineString(literal), ...rest ] => (TomlString(escapeString(literal, true, true)), rest),
    // Parse Literals
    [Literal(bool),...rest] when String.trim(bool) == "true" => (TomlBool(true), rest),
    [Literal(bool),...rest] when String.trim(bool) == "false" => (TomlBool(false), rest),
    // TODO: DateTime
    // Float
    [Literal(int),...rest] when isFloat(int) => {
      match (Number.parseFloat(int)) {
        Ok(int) => (TomlFloat(int), rest),
        Err(_) => fail "Invalid Toml Float"
      }
    },
    // Number
    [Literal(int),...rest] when isNumber(int) => {
      let mut int = int
      match (Array.toList(String.explode(int))) {
        [ '+', ...rest ] => int = String.implode(Array.fromList(rest)),
        _ => void
      }
      match (Number.parseInt(int, 10)) {
        Ok(int) => (TomlInt(int), rest),
        Err(_) => fail "Invalid Toml Integer"
      }
    },
    // Unknown
    _ => fail "Unknown Value"
  }
}
// Public Api
provide let fromString = (str) => {
  // Lex
  let mut buffer = lex(str)
  // Parse
  let mut keyPath = []
  let mut rootTable = TomlTable([])
  while (List.length(buffer) > 0) {
    // Expressions
    // TODO: Handle Proper Validation
    match (buffer) {
      // Table
      [ Sbo, Literal(tableName), Sbc, ...rest ] => {
        buffer = rest
        // Validate Table name
        if (!isValidKeyTable(tableName)) fail "Invalid Table Name"
        // Write Table Name
        keyPath = parseKey(tableName)
        // Write To Current Table
        rootTable = writeTable(rootTable, keyPath, TomlTable([]))
      },
      // Table Array
      [ Sbo, Sbo, Literal(tableName), Sbc, Sbc, ...rest ] => {
        buffer = rest
        // Validate Table name
        if (!isValidKeyTable(tableName)) fail "Invalid Table Name"
        // Write Table Name
        keyPath = parseKey(tableName)
        // Write Current Table
        rootTable = writeTable(rootTable, keyPath, TomlArray([]))
        // TODO: Handle Writing To Arrays
      },
      // Line Break
      [ LineBreak, LineBreak, ...rest ] => {
        buffer = rest
        // Reset Current Table Name
        keyPath = []
      },
      [ LineBreak, ...rest ] => buffer = rest,
      // Key Value
      [ Literal(keyName), Eq, ...rest ] => {
        buffer = rest
        // Validate Key Name
        if (!isValidKeyTable(keyName)) fail "Invalid Key Name"
        // Parse Key
        let key = List.append(keyPath, parseKey(keyName))
        // Parse The Value
        let (value, rest) = parseValue(rest)
        buffer = rest
        // Write To Current Table
        rootTable = writeTable(rootTable, key, value)
      },
      // Invalid
      _ => fail "Invalid Toml"
    }
  }
  // Return Parsed
  Ok(rootTable)
}
