module Lexer
include "bytes"
include "list"
include "string"
// Type
provide enum Token {
  Literal(String),
  Eq,
  Sbo,
  Cbo,
  Sbc,
  Cbc,
  Hash,
  DoubleQuote,
  SingleQuote,
  LineBreak,
  CarriageReturn,
  BackSlash,
  Comma,
  WhiteSpace,
}
// Stream
record Stream {
  data: Bytes,
  mut index: Number,
}
let streamFromString = (str) => {
  let bytes = Bytes.fromString(str)
  {
    data: bytes,
    index: 0,
  }
}
let getStreamLength = (stream) => {
  Bytes.length(stream.data) - stream.index
}
let streamIsEmpty = (stream) => {
  getStreamLength(stream) == 0
}
let streamPeekUint8 = (stream) => {
  let byte = Bytes.getUint8(stream.index, stream.data)
  byte
}
let streamNextUint8 = (stream) => {
  let byte = streamPeekUint8(stream)
  stream.index += 1
  byte
}
// Helpers
let getSpecialByte = (n) => {
  match (n) {
    0x3Dus => Some(Eq), // =
    0x5Bus => Some(Sbo), // [
    0x5Dus => Some(Sbc), // ]
    0x7Bus => Some(Cbo), // {
    0x7Dus => Some(Cbc), // }
    0x23us => Some(Hash), // #
    0x2Cus => Some(Comma), // ,
    0x27us => Some(SingleQuote), // '
    0x22us => Some(DoubleQuote), // "
    0x0Aus => Some(LineBreak), // \n
    0x0Dus => Some(CarriageReturn), // \r
    0x5Cus => Some(BackSlash), // \
    // WhiteSpace
    0x20us => Some(WhiteSpace), // Space
    0x09us => Some(WhiteSpace), // Tab
    _ => None,
  }
}
// Lex
provide let lex = (inputStr) => {
  let data = streamFromString(inputStr)
  let mut lexemes = []
  while (!streamIsEmpty(data)) {
    let byte = streamNextUint8(data)
    let lexValue = getSpecialByte(byte)
    match (lexValue) {
      // TODO: Handle Escapes
      Some(WhiteSpace) => continue,
      Some(Hash) => {
        while (getStreamLength(data) > 0) {
          let nextByte = streamPeekUint8(data)
          if (nextByte == 0x0Aus) break //\n
          else ignore(streamNextUint8(data))
        }
      },
      Some(SingleQuote) => {
        lexemes = [ SingleQuote, ...lexemes]
        let index = data.index
        let mut alphabetic_index = 0
        let mut maxQuoteCount = 1
        let mut quoteCount = 1
        let mut hasHitSomething = false
        while (!streamIsEmpty(data)) {
          let nextByte = streamPeekUint8(data)
          let nextValue = getSpecialByte(nextByte)
          match (nextValue) {
            Some(SingleQuote) => {
              alphabetic_index += 1
              streamNextUint8(data)
              if (!hasHitSomething) {
                quoteCount += 1
                maxQuoteCount += 1
                lexemes = [ SingleQuote, ...lexemes]
              } else if (quoteCount > 1) {
                quoteCount -= 1
              } else {
                break
              }
            },
            _ => {
              hasHitSomething = true
              quoteCount = maxQuoteCount
              streamNextUint8(data)
              alphabetic_index += 1
            },
          }
        }
        let relative_index = alphabetic_index - 1
        let string_bytes = Bytes.slice(index, relative_index, data.data)
        let string = Bytes.toString(string_bytes)
        lexemes = [ Literal(string), ...lexemes ]
        for (let mut i = 0; i < maxQuoteCount; i += 1) {
          lexemes = [ SingleQuote, ...lexemes ]
        }
      },
      Some(DoubleQuote) => {
        lexemes = [ DoubleQuote, ...lexemes]
        let index = data.index
        let mut alphabetic_index = 0
        let mut maxQuoteCount = 1
        let mut quoteCount = 1
        let mut hasHitSomething = false
        while (!streamIsEmpty(data)) {
          let nextByte = streamPeekUint8(data)
          let nextValue = getSpecialByte(nextByte)
          match (nextValue) {
            Some(DoubleQuote) => {
              alphabetic_index += 1
              streamNextUint8(data)
              if (!hasHitSomething) {
                quoteCount += 1
                maxQuoteCount += 1
                lexemes = [ DoubleQuote, ...lexemes]
              } else if (quoteCount > 0) {
                quoteCount -= 1
              } else {
                break
              }
            },
            _ => {
              hasHitSomething = true
              quoteCount = maxQuoteCount
              streamNextUint8(data)
              alphabetic_index += 1
            },
          }
        }
        let relative_index = alphabetic_index
        let string_bytes = Bytes.slice(index, relative_index, data.data)
        let string = Bytes.toString(string_bytes)
        lexemes = [ Literal(string), ...lexemes ]
        for (let mut i = 0; i < maxQuoteCount; i += 1) {
          lexemes = [ DoubleQuote, ...lexemes ]
        }
      },
      Some(CarriageReturn) => {
        let entry = if (!streamIsEmpty(data) && streamPeekUint8(data) == 0x0Aus) { // \n
          streamNextUint8(data)
          LineBreak
        } else CarriageReturn
        lexemes = [ entry, ...lexemes ]
      },
      Some(x) => lexemes = [ x, ...lexemes ],
      _ => {
        let index = data.index
        let mut alphabetic_index = 0
        while (!streamIsEmpty(data)) {
          let nextByte = streamPeekUint8(data)
          if (getSpecialByte(nextByte) == None) {
            streamNextUint8(data)
            alphabetic_index += 1
          } else {
            break
          }
        }
        let relative_index = alphabetic_index + 1
        let string_bytes = Bytes.slice(index-1, relative_index, data.data)
        let string = Bytes.toString(string_bytes)
        lexemes = [ Literal(string), ...lexemes ]
      }
    }
  }
  List.reverse(lexemes)
}
